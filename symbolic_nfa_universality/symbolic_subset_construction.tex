\documentclass{llncs}

\usepackage[usenames,dvipsnames]{color}

\let\iint\undefined 
\let\iiint\undefined 
\let\iiiint\undefined 
\let\idotsint\undefined

\usepackage{amsmath} 
\usepackage{amsxtra} 
\usepackage{amssymb}
\usepackage{mathabx}
\usepackage{mathtools}
\usepackage{textcomp}

\usepackage{latexsym}
\usepackage{pslatex}
\usepackage{epsfig}
\usepackage{wrapfig}
%\usepackage{graphics}
\usepackage{enumerate}
\usepackage{cancel}

\usepackage{paralist}

\usepackage{ listings }

\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}
\let\Asterisk\undefined

\pagestyle{empty}

\include{commands}

\newcommand{\Xobs}{\vec{x}}
\newcommand{\Xinv}{\vec{y}}
\newcommand{\Xinvz}{\vec{z}}

\newcommand{\vx}{\vec{x}}
\newcommand{\vy}{\vec{y}}
\newcommand{\vz}{\vec{z}}
\newcommand{\dom}{\mathcal{D}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\title{Trace Inclusion of Infinite State Systems with Local Information}
\title{Predicate Abstraction for Trace Inclusion}

\author{Luk\'{a}\v{s} Hol\'{i}k\inst{1} \and Radu Iosif\inst{2} \and Adam Rogalewicz\inst{1} \and
Tom\'{a}\v{s}~Vojnar\inst{1}}
  
\institute{
  FIT, Brno University of Technology, IT4Innovations Centre of Excellence, 
  Czech Republic
  \and 
  University Grenoble Alpes, CNRS, VERIMAG, Grenoble, France
}
  
 \maketitle


\begin{abstract}\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Treansition Syatems}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let $\nat$ denote the set of non-negative integers including zero. For
any $k,\ell \in \nat$, $k \leq \ell$, we write $[k,\ell]$ for the set
$\set{k,k+1,\ldots,\ell}$. We write $\false$ and $\true$ for the
boolean constants \emph{false} and \emph{true}, respectively. Given a
possibly infinite data domain $\mathcal{D}$, we denote by
$\thd=\tuple{\mathcal{D}, p_1,\ldots,p_n, f_1,\ldots,f_m}$ the set of
syntactically correct first-order formulae with predicate
symbols $p_1,\ldots,p_n$ and function symbols $f_1,\ldots,f_m$. A variable $x$
is said to be \emph{free} in a~formula $\phi$, denoted as $\phi(x)$,
iff it does not occur under the scope of a~quantifier.

Let $\vec{x} = \set{x_1,\ldots,x_n}$ be a finite set of variables. A
\emph{valuation} $\nu : \vec{x} \rightarrow \mathcal{D}$ is an
assignment of the variables in $\vec{x}$ with values from
$\mathcal{D}$. We denote by $\mathcal{D}^\vec{x}$ the set of such
valuations. For a formula $\phi(\vec{x})$, we denote by $\nu
\modelsthd \phi$ the fact that substituting each variable $x \in
\vec{x}$ by $\nu(x)$ yields a valid formula in the theory $\thd$. In
this case, $\nu$ is said to be a~\emph{model} of $\phi$. A formula is
said to be {\em satisfiable} iff it has a model. For a~formula
$\phi(\vec{x}, \vec{x'})$ where $\vec{x'} = \set{x' ~|~ x \in
  \vec{x}}$ and two valuations $\nu,\nu' \in \mathcal{D}^{\vec{x}}$,
we denote by $(\nu,\nu') \modelsthd \phi$ the fact that the formula
obtained from $\phi$ by substituting each $x$ with $\nu(x)$ and each
$x'$ with $\nu'(x')$ is valid in $\thd$.

\newcommand{\initial}{I}
\newcommand{\accepting}{F}
\newcommand{\transition}{\tau}
\paragraph{Transition system.} 
Let $\mathcal{D}$ be an infinite date domain equipped with a first order theory $\thd$.
%
Let $\Xobs$ be the set of observable and $\Xinv$ the set of invisible variables.
%
A transition system (TS) is a triple formula $T = (\initial(\Xobs,\Xinv),\transition(\Xobs,\Xinv,\Xobs', \Xinv'),\accepting(\Xobs,\Xinv))$ where $\initial$ is a fomrula describing initial valuations, $\transition(\Xobs,\Xinv,\Xobs', \Xinv')$ describes the transition relation, and $\accepting(\Xobs,\Xinv)$ describes accepting valuations.
%
We say that a valuation $\nu'$ is 
a~\emph{successor} of $\nu$ if and only if and $(\nu,\nu') \modelsthd
\transition$. We denote the successor relation by $\nu
\arrow{\transition}{} \nu'$, and we omit writing $\transition$ 
when no confusion may arise. We write 
$\mathit{succ}(\nu)$ to denote $\nu'$.


A \emph{run} of $\transition$ is a sequence
of valuations $\pi : \nu_0 \arrow{\transition}{}  \ldots \arrow{\transition}{} \nu_n$ where $\nu_0\models\initial$. It is accepting if also $\nu_n\models\accepting$.
Each run corresponds to a \emph{trace}, which is a finite sequence
$w(\pi)=\nu_0\proj_{\Xobs}, \ldots,
\nu_n\proj_{\Xobs}$.
%
The \emph{language} of $A$ is the set of traces 
$\mathcal{L}(T) = \{w(\pi)\mid \pi \text{ is a run of } T\}$.

\paragraph{Trace Inclusion.} Let 
$\transition({\Xobs},{\Xinv},{\Xobs}',{\Xinv}')$ 
and
$\mu({\Xobs},{\Xinvz},{\Xobs}',{\Xinvz}')$ be two TS. The \emph{trace
  inclusion problem} asks whether $\mathcal{L}(\mathcal{A})
\subseteq \mathcal{L}(B)$.

\newcommand{\viz}{x}
\newcommand{\inviz}{y}
\newcommand{\domain}{\mathcal {D}}
\newcommand{\dvalue}{d}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Subset Construction and Universality}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For simplicity, let us have one visible variable $x$ and one invisible variable $y$.
A trace is then just a sequence $d_0\cdots d_k$ of elements of the domain.

This is a formula describing a relation between the current state after $k$ steps (that is, the values of $\viz$ and $\inviz$) and the global trace leading to it (that is, the values of $\viz_0,\ldots,\viz_k$):
$$
M_k(\viz_0,\ldots,\viz_k,\inviz,\viz) \equiv \exists \inviz_0\cdots \inviz_{k}:  I[x,y/x_0,y_0] \land \bigwedge_{i=1}^k \transition[\viz,\inviz,\viz',\inviz'/\viz_{i-1},\inviz_{i-1},\viz_i,\inviz_i] \land \viz = \viz_k \land \inviz = \inviz_k 
$$
%We note that in our automata, the state is determined by the last transition taken. 
We note that in the formula, the current state is the $k$th value of the variables, which is copied as into the unindexed variables $x,y$.  
%our automata, the state is determined by the last transition taken, and in the formu. 

Every global trace gives a macrostate (subset of states of the system) to which the normal subset construction would arrive via that trace.
That is, for every $k$-tuple (trace) $w = \dvalue_0\cdots\dvalue_k \in \domain^k$, the formula 
$$M_{w}(\viz,\inviz) \equiv \exists \viz_0\cdots \viz_{k}: M_k \land \bigwedge_{i=0}^k{\viz_i = \dvalue_i}$$ 
or equivalently
$$M_{w}(\viz,\inviz) \equiv M_k [\viz_0,\ldots,\viz_k/\dvalue_0,\ldots,\dvalue_k] $$ 
is one macrostate. 

The relation between macrostates and the traces up-to $k$ steps by which they are reached is captured by the formula  
$$\bigvee_{i=0}^k M_k$$

That all macrostates reached by traces of the lenght $k+1$ have already been reached by shorter traces should be expressed by the formula
$$
\mathit{fixpoint}_k = \forall \viz_0'\cdots\viz_{k+1}'\exists \viz_0\cdots\viz_{k} :
M_{k+1}[\viz_0,\ldots,\viz_{k+1}/\viz'_0,\ldots,\viz'_{k+1}]
\iff 
 \bigvee_{i=0}^k M_k 
$$

So the symbolic version of the standart subset construction would generate the sequence $M_0,M_1,\ldots$ and terminate with $\bigvee_{i=0}^k M_k$ when $\mathit{fixpoint}_k$ holds.    
Of course it does not have to terminate and we will try to use predicate abstraction to make it terminate more often.

A universality test would ask whether every reachable macrostate contains an accepting valuation: 
$$
\forall \viz_0\cdots\viz_k \exists x y:  \bigvee_{i=0}^k M_k \land \accepting
$$

For the purpose of the universality checking,
the fixpoint condition can be weakened in the spirit of antichains:
$$
\mathit{fixpoint}'_k = \forall \viz_0'\cdots\viz_{k+1}'\exists \viz_0\cdots\viz_{k} :
M_{k+1}[\viz_0,\ldots,\viz_{k+1}/\viz'_0,\ldots,\viz'_{k+1}]
\Leftarrow
\bigvee_{i=0}^k M_k 
$$
That is, for every newly generated macroste, there already has been a smaller one.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{splncs03}
\bibliography{ref}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
