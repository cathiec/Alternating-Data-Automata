\documentclass{llncs}
% \documentclass[10pt,conference,letterpaper,twocolumn]{IEEEtran}

\usepackage[usenames,dvipsnames]{color}

\usepackage{latexsym}
\usepackage{amsxtra} 
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{pslatex}
\usepackage{epsfig}
\usepackage{wrapfig}
\usepackage{paralist}
% \usepackage{stmaryrd}
\usepackage{txfonts}
\usepackage{framed}
\usepackage{makecell}
\usepackage{url}
\usepackage{tikz}
\usetikzlibrary{automata,positioning, calc}
\usepackage[inline,shortlabels]{enumitem}

\usepackage{proof}

\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}

\usepackage[draft]{commenting}

\pagestyle{plain}

\include{commands-lncs}

\declareauthor{ri}{Radu}{blue}
\declareauthor{xx}{Xiao}{red}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{First Order Alternation}

\author{Radu Iosif and Xiao Xu}
\institute{
  CNRS, Verimag, Universit\'e de Grenoble Alpes \\
  Email: \{Radu.Iosif,Xiao.Xu\}@univ-grenoble-alpes.fr
}

\maketitle

\begin{abstract}
\end{abstract}

\section{Preliminaries}

For two integers $0 \leq i \leq j$, we denote by $[i,j]$ the set
$\set{i,i+1,\ldots,j}$ and by $[i]$ the set $[0,i]$. We consider two
sorts $\Data$ and $\Bool$, where $\Data$ is an infinite domain and
$\Bool = \set{\top,\bot}$ is the set of boolean values true ($\top$)
and false ($\bot$), respectively. The $\Data$ sort is equipped with
finitely many function symbols $f : \Data^{\#(f)} \rightarrow \Data$,
where $\#(f)\geq0$ denotes the number of arguments (arity) of
$f$. When $\#(f)=0$, we say that $f$ is a constant. A \emph{predicate}
is a function symbol $p : \Data^{\#(p)} \rightarrow \Bool$, denoting a
relation of arity $\#(p)$ and we write $\preds$ for the set of
predicates. 

In the following, we shall consider that the interpretation of all
function symbols $f : \Data^{\#(f)} \rightarrow \Data$ that are not
predicates is fixed by the interpretation of the $\Data$ sort,
e.g.\ if $\Data$ is the set of integers $\zed$, the function symbols
are zero, the successor function and the arithmetic operations of
addition and multiplication. For simplicity, we further blur the
notational distinction between function symbols and their
interpretations.

Let $\vars = \set{x,y,z,\ldots}$ be an infinite countable set of
variables, ranging over $\Data$. Terms are either constants of sort
$\Data$, variables or function applications $f(t_1,\ldots,t_{\#(f)})$,
where $t_1,\ldots,t_{\#(f)}$ are terms. The set of first-order
formulae is defined by the syntax below:
\[\phi := t \teq s \mid p(t_1,\ldots,t_{\#(p)}) 
\mid \neg \phi_1 \mid \phi_1 \wedge \phi_2 \mid \exists x ~.~
\phi_1 \] where $t,s,t_1,\ldots,t_{\#(p)}$ denote terms. We write
$\phi_1 \vee \phi_2$, $\phi_1 \rightarrow \phi_2$ and $\forall x ~.~
\phi_1$ for $\neg(\neg\phi_1 \wedge \neg\phi_2)$, $\neg\phi_1 \vee
\phi_2$ and $\neg\exists x ~.~ \neg\phi_1$, respectively. We denote by
$\fv{}{\phi}$ the set of free variables in $\phi$. A \emph{sentence}
is a formula $\phi$ in which each variable occurs under the scope of a
quantifier, i.e. $\fv{}{\phi} = \emptyset$. A formula is
\emph{positive} if each predicate symbol occurs under an even number
of negations. The size $\len{\phi}$ of a formula $\phi$ is the number
of symbols needed to write it down.

%% For a variable $x \in \fv{}{\phi}$ and a term $t$, let $\phi[t/x]$ be
%% the result of replacing each occurrence of $x$ by $t$. For indexed
%% sets of terms $T=\set{t_1,\ldots,t_n}$ and variables
%% $X=\set{x_1,\ldots,x_n}$, we write $\phi[T/X]$ for the formula
%% obtained by simultaneously replacing each occurrence of $x_i$ with
%% $t_i$ in $\phi$, for all $i\in[n]$.

An \emph{interpretation} $\I$ maps each predicate $p$ into a set $p^\I
\subseteq \Data^{\#(p)}$, if $\#(p)>0$, or into an element of $\Data$
if $\#(p)=0$. A \emph{valuation} $\nu$ maps each variable $x$ into an
element of $\Data$. Given a term $t$, we denote by $t^\nu$ the value
obtained by replacing each variable $x$ by the value $\nu(x)$ and
evaluating each function application. For a formula $\phi$, we define
the forcing relation $\I,\nu \models \phi$ recursively on the
structure of $\phi$, as follows:
\[
\begin{array}{rcl}
\I,\nu \models t \teq s & \iff & t^\nu=s^\nu \\
\I,\nu \models p(t_1,\ldots,t_{\#(p)}) & \iff & \tuple{t_1^\nu,\ldots,t_{\#(p)}^\nu} \in p^\I \\
\I,\nu \models \neg\phi_1 & \iff & \I,\nu \not\models \phi_1 \\
\I,\nu \models \phi_1 \wedge \phi_2 & \iff & \I,\nu \models \phi_i \text{, for all } i=1,2 \\ 
\I,\nu \models \exists x ~.~ \phi_1 & \iff & \I,\nu[x\leftarrow d] \models \phi_1 \text{, for some } d \in \Data 
\end{array}
\]
where $\nu[x\leftarrow d]$ is the valuation which assigns $d$ to $x$
and behaves like $\nu$ elsewhere. For a formula $\phi$ and a valuation
$\nu$, we define $\sem{\phi}_\nu \isdef \set{\I \mid \I,\nu \models
  \phi}$ and drop the $\nu$ subscript for sentences. A sentence $\phi$
is \emph{satisfiable} (\emph{unsatisfiable}) if
$\sem{\phi}\neq\emptyset$ ($\sem{\phi}=\emptyset$). An element of
$\sem{\phi}$ is called a \emph{model} of $\phi$. A formula $\phi$ is
\emph{valid} if $\I,\nu \models \phi$ for every interpretation $\I$
and every valuation $\nu$.

Interpretations are partially ordered by the pointwise subset order,
defined as $\I_1 \subseteq \I_2$ if and only if $p^{\I_1} \subseteq
p^{\I_2}$ for each predicate $p \in \preds$. Given a set $\mathcal{S}$
of interpretations, a minimal element $\I \in \mathcal{S}$ is an
interpretation such that for no other interpretation $\I' \in
\mathcal{S} \setminus \set{\I}$ do we have $\I' \subseteq \I$. For a
formula $\phi$ and a valuation $\nu$, we denote by $\minsem{\phi}_\nu$
and $\minsem{\phi}$ the set of minimal interpretations from
$\sem{\phi}_\nu$ and $\sem{\phi}$, respectively.

\section{First Order Alternating Automata}

Let $\Sigma$ be a finite alphabet $\Sigma$ of \emph{input
  events}. Given a finite set of variables $X \subseteq \vars$, we denote by $X
\mapsto \Data$ the set of valuations of the variables $X$ and
$\Sigma[X] = \Sigma \times (X \mapsto \Data)$ be the possibly infinite
set of \emph{data symbols} $(a,\nu)$, where $a$ is an input symbol and
$\nu$ is a valuation. A \emph{data word} (simply called word in the
following) is a finite sequence $w=(a_1,\nu_1)(a_2,\nu_2) \ldots
(a_n,\nu_n)$ of data symbols. Given a word $w$, we denote by
$\event{w} \isdef a_1\ldots a_n$ its sequence of input events and by
$\data{w}$ the valuation associating each time-stamped variable
$\stamp{x}{i}$ the value $\nu_i(x)$, for all $x \in \vars$ and
$i\in[1,n]$. We denote by $\varepsilon$ the empty sequence, by
$\Sigma^*$ the set of finite sequences of input events and by
$\Sigma[X]^*$ the set of data words over the variables $X$.

A \emph{first-order alternating automaton} (automaton) is a tuple $\A
= \tuple{\Sigma,X,Q,\iota,F,\Delta}$, where: \begin{compactitem}
\item $\Sigma$ is the finite set of input events, 
\item $X$ is a finite set of input variables, 
\item $Q$ is a finite set of predicates denoting control states, 
\item $\iota$ is a sentence defining initial configurations,
\item $F \subseteq Q$ is the set of predicates denoting final states, and 
\item $\Delta$ is a set of \emph{transition rules} of the form
  \(q(y_1,\ldots,y_{\#(q)}) \arrow{a(X)}{} \psi\), where $q \in Q$ is
  a predicate, $a \in \Sigma$ is an input event, $X \cap
  \set{y_1,\ldots,y_{\#(q)}} = \emptyset$, $\psi$ is a positive
  formula such that $\fv{}{\phi} \subseteq X \cup
  \set{y_1,\ldots,y_{\#(q)}}$ and each predicate that occurs (under an
  even number of negations) in $\psi$ belongs also to $Q$. The
  quantifiers occurring in $\psi$ are referred to as \emph{transition
    quantifiers}.
\end{compactitem}
The \emph{size} of $\A$ is defined as $\len{\A} = \len{\iota} +
\sum_{\scriptscriptstyle{q(\vec{y}) \arrow{a(X)}{} \psi \in \Delta}}
\len{\psi}$.

The intuition of a transition rule \(q(y_1,\ldots,y_{\#(q)})
\arrow{a(X)}{} \psi\) is the following: $a$ is the input event and $X$
are the input data values that trigger the transition, whereas $q$ and
$y_1,\ldots,y_{\#(q)}$ are the current control state and data values
in that state, respectively. Without loss of generality, we consider,
for each predicate $q \in Q$ and each input event $a \in \Sigma$, at
most one such rule --- two or more rules can be joined using
disjunction. 

The execution semantics of automata is given in close analogy with the
case of boolean alternating automata, with transition rules of the
form $q \arrow{a}{} \phi$, where $q$ is a boolean constant and $\phi$
a positive boolean combination of such constants. For instance, $q_0
\arrow{a}{} q_1 \wedge q_2 \vee q_3$ means that the automaton can
choose to transition in either both $q_1$ and $q_2$ or in $q_3$
alone. This intuition leads to saying that the steps of the automaton
are defined by the minimal boolean models of the transition
formulae. In this case, both $\set{q_1 \leftarrow \top, q_2 \leftarrow
  \top, q_3 \leftarrow \bot}$ and $\set{q_1 \leftarrow \bot, q_2
  \leftarrow \bot, q_3 \leftarrow \top}$ are minimal models, however
$\set{q_1 \leftarrow \top, q_2 \leftarrow \top, q_3 \leftarrow \top}$,
is a model but is not minimal\footnote{To avoid the confusion of
  considering potentially non-minimal models, the original definition
  of alternating finite-state automata \cite{ChandraKozenStockmeyer81}
  uses boolean valuations instead of formulae.}.

Given a predicate $q \in Q$ and a tuple of data values
$d_1,\ldots,d_{\#(q)}$, the tuple $q(d_1,\ldots,d_{\#(q)})$ is called
a \emph{configuration}\footnote{Note that a configuration is not a
  logical term since data values cannot be written in logic.}. To
formalize the execution semantics of automata, we relate sets of
configurations to models of first-order sentences, as follows. Given a
formula $\phi$ and a valuation of its free variables $\nu$, each
interpretation $\I \in \sem{\phi}_\nu$ corresponds to a set of
configurations $\cube{\I} \isdef \set{q(d_1,\ldots,d_{\#(q)}) \mid q
  \in Q,~ \tuple{d_1,\ldots,d_{\#(q)}} \in q^\I}$, called a
\emph{cube}. For a set $\mathcal{S}$ of interpretations, we define
$\cube{\mathcal{S}} \isdef \set{\cube{\I} \mid \I \in
  \mathcal{S}}$. 

Given a word $w=(a_1,\nu_1) \ldots (a_n,\nu_n) \in \Sigma[X]^*$, an
\emph{execution} of $\A=\tuple{\Sigma,X,Q,\iota,F,\Delta}$ over $w$ is
a (possibly infinite) forest $\T = \set{T_1,T_2,\ldots}$, where each
$T_i$ is a tree labeled with configurations, such that:
\begin{compactitem}
\item the labels of the roots of $T_1, T_2, \ldots$ form a cube from
  $\cube{\minsem{\iota}}$,
%
\item if $q(d_1,\ldots,d_{\#(q)})$ labels a node on the level $j \in
  [n-1]$ in $T_i$, then the labels of its children form a cube from
  $\cube{\minsem{\psi}_{\nu_{j+1}[y_1 \leftarrow d_1,\ldots,y_{\#(q)}
        \leftarrow d_{\#(q)}]}}$, where \(q(y_1,\ldots,y_{\#(q)})
  \arrow{a_{j+1}(X)}{} \psi \in \Delta\) is a transition rule.
\end{compactitem}
An execution $\T$ over $w$ is said to be \emph{accepting} if and only
if \begin{inparaenum}[(i)]
\item all paths in $\T$ have the same length $n$, and
\item the frontier of each tree $T \in \T$ is labeled with \emph{final
  configurations} $q(d_1,\ldots,d_{\#(q)})$, where $q \in F$.
\end{inparaenum} In this case, we say that $\A$ accepts $w$ and
denote by $\lang{\A}$ the set of words accepted by $\A$. 

In this paper, we address the following questions: \begin{compactenum}
\item \emph{boolean closure}: given automata $\A_i =
  \tuple{\Sigma,X,Q_i,\iota_i,F_i,\Delta_i}$, for $i=1,2$, do there
  exist automata $\A_\cap$, $\A_\cup$ and $\overline{\A}_1$ such that
  $L(\A_\cap) = L(\A_1) \cap L(\A_2)$, $L(\A_\cup) = L(\A_1) \cup
  L(\A_2)$ and $L(\overline{\A}_1) = \Sigma[X]^* \setminus L(\A_1)$ ?
%
\item \emph{emptiness}: given an automaton $\A$, is $L(\A) =
  \emptyset$?
\end{compactenum}

\subsection{Symbolic Execution}

In the upcoming developments it is sometimes more convenient to work
with logical formulae defining executions of automata, than with
low-level execution forests. For this reason, we first introduce
\emph{path formulae} $\pathform{\alpha}$, which are formulae defining
the executions of an automaton, over words that share a given sequence
$\alpha$ of input events.  Second, we restrict a path formula
$\pathform{\alpha}$ to an \emph{acceptance formula}
$\accform{\alpha}$, which defines only accepting executions over words
that share a given input sequence. Otherwise stated,
$\accform{\alpha}$ is satisfiable if and only if the automaton accepts
a word $w$ such that $w_\Sigma = \alpha$.

Let $\A = \tuple{\Sigma,X,Q,\iota,F,\Delta}$ be an automaton for the
rest of this section. For any $i \in \nat$, we denote by $\stamp{Q}{i}
= \set{\stamp{q}{i} \mid q \in Q}$ and $\stamp{X}{i} =
\set{\stamp{x}{i} \mid x \in X}$ the sets of time-stamped predicates
and variables, respectively. As a shorthand, we write $\stamp{Q}{\leq
  n}$ (resp.  $\stamp{X}{\leq n}$) for the set $\set{\stamp{q}{i} \mid
  q \in Q, i \in [n]}$ (resp. $\set{\stamp{x}{i} \mid x \in X, i \in
  [n]}$). For a formula $\psi$ and $i \in \nat$, we define
$\stamp{\psi}{i} \isdef \psi[\stamp{X}{i}/X,\stamp{Q}{i}/Q]$ the
formula in which all input variables and state predicates (and only
those symbols) are replaced by their time-stamped counterparts. As a
shorthand, we shall write $q(\vec{y})$ for $q(y_1,\ldots,y_{\#(q)})$,
when no confusion arises.

Given a sequence of input events $\alpha = a_1 \ldots a_n$, the
\emph{path formula} of $\alpha$ is defined as:
\begin{equation}\label{eq:pathform}
\pathform{\alpha} \isdef \stamp{\iota}{0} \wedge 
\bigwedge_{i=1}^n \bigwedge_{q(\vec{y}) \arrow{a_i(X)}{}
  \psi \in \Delta} \forall y_1 \ldots \forall y_{\#(q)} ~.~
\stamp{q}{i-1}(\vec{y}) \rightarrow \stamp{\psi}{i}
\end{equation}
The automaton $\A$, to which $\pathform{\alpha}$ refers, will always
be clear from the context. To formalize the relation between the
low-level configuration-based execution semantics and the symbolic
path formulae, consider a word $w=(a_1,\nu_1) \ldots (a_n,\nu_n)$. Any
execution forest $\T$ of $\A$ over $w$ is associated an interpretation
$\I_{\T}$ of the set of time-stamped predicates $\stamp{Q}{\leq n}$,
defined as:
\[\I_{\T}(\stamp{q}{i}) \isdef \set{\tuple{d_1,\ldots,d_{\#(q)}} \mid
  q(d_1,\ldots,d_{\#(q)}) \text{ labels a node on level $i$ in $\T$}}\]

\begin{lemma}\label{lemma:path-formula}
  Given an automaton $\A = \tuple{\Sigma,X,Q,\iota,F,\Delta}$, for any
  word $w=(a_1,\nu_1) \ldots (a_n,\nu_n)$, we have 
  \(\minsem{\pathform{w_\Sigma}}_{w_\Data} = \set{\I_{\T} \mid \T
    \text{ is an execution of $\A$ over $w$}}\). 
\end{lemma}
\proof{ ``$\subseteq$'' Let $\I$ be a minimal interpretation such that
  $\I,w_\Data \models \pathform{w_\Sigma}$. We show that there exists
  an execution $\T$ of $\A$ over $w$ such that $\I = \I_\T$, by
  induction on $n\geq 0$. For $n=0$, we have $w=\epsilon$ and
  $\pathform{w_\Sigma} = \stamp{\iota}{0}$. Because $\iota$ is a
  sentence, the valuation $w_\Data$ is not important in $\I,w_\Data
  \models \stamp{\iota}{0}$ and, moreover, since $\I$ is minimal, we
  have $\I \in \minsem{\stamp{\iota}{0}}$. We define the
  interpretation $\J(q)=\I(\stamp{q}{0})$, for all $q \in Q$. Then
  $\cube{\J}$ is an execution of $\A$ over $\epsilon$ and $\I =
  \I_{\cube{\J}}$ is immediate. For the inductive case $n>0$, we
  assume that $w=u\cdot(a_n,\nu_n)$ for a word $u$. Let $\J$ be the
  interpretation defined as $\I$ for all $\stamp{q}{i}$, with $q \in
  Q$ and $i \in [n-1]$, and $\emptyset$ everywhere else. Then
  $\J,u_\Data \models \pathform{u_\Sigma}$ and $\J$ is moreover
  minimal. By the induction hypothesis, there exists an execution $\G$
  of $\A$ over $u$, such that $\J = \I_\G$. Consider a leaf of a tree
  $T \in \G$, labeled with a configuration $q(d_1,\ldots,d_{\#(q)})$
  and let $\forall y_1 \ldots \forall y_{\#(q)} ~.~
  \stamp{q}{n-1}(\vec{y}) \rightarrow \stamp{\psi}{n}$ be the
  subformula of $\pathform{w_\Sigma}$ corresponding to the
  application(s) of the transition rule $q(\vec{y}) \arrow{a_n}{}
  \psi$ at the $(n-1)$-th step. Let $\nu = w_\Data[y_1 \leftarrow
    d_1,\ldots,y_{\#(q)} \leftarrow d_{\#(q)}]$. Because $\I, w_\Data
  \models \forall y_1 \ldots \forall y_{\#(q)} ~.~
  \stamp{q}{n-1}(\vec{y}) \rightarrow \stamp{\psi}{n}$, we have $\I
  \in \sem{\stamp{\psi}{n}}_{\nu}$ and let $\K$ be one of the minimal
  interpretations such that $\K \subseteq \I$ and $\K \in
  \sem{\stamp{\psi}{n}}_{\nu}$. It is not hard to see that $\K$ exists
  and is unique, otherwise we could take the pointwise intersection of
  two or more such interpretations. We define the interpretation
  $\overline{\K}(q) = \overline{\K}(\stamp{q}{n})$ for all $q \in
  Q$. We have that $\overline{\K} \in \minsem{\psi}_{\nu}$ --- if
  $\overline{\K}$ was not minimal, $\K$ was not minimal to start with,
  contradiction. Then we extend the execution $\G$ by appending to
  each node labeled with a configuration $q(d_1, \ldots, d_{\#(q)})$
  the cube $\cube{\overline{\K}}$. By repeating this step for all
  leaves of a tree in $\G$, we obtain an execution of $\A$ over $w$.
  
  ``$\supseteq$'' Let $\T$ be an execution of $\A$ over $w$. We show
  that $\I_{\T}$ is a minimal interpretation such that $\I_{\T},
  w_\Data \models \pathform{w_\Sigma}$, by induction on $n \geq
  0$. For $n=0$, $\T$ is a cube from $\cube{\minsem{\iota}}$, by
  definition. Then $\I_{\T} \models \stamp{\iota}{0}$ and moreover, it
  is a minimal such interpretation. For the inductive case $n > 0$,
  let $w=u\cdot(a_n,\nu_n)$ for a word $u$. Let $\G$ be the
  restriction of $\T$ to $u$. Consequently, $\I_\G$ is the restriction
  of $\I_\T$ to $\stamp{Q}{\leq n-1}$. By the inductive hypothesis,
  $\I_{\G}$ is a minimal interpretation such that \(\I_{\G}, u_{\Data}
  \models \pathform{u_\Sigma}\). Since $\I_{\T}(\stamp{q}{n}) =
  \set{\tuple{d_1,\ldots,d_{\#(q)}} \mid q(d_1,\ldots,d_{\#(q)})
    \text{ labels a node on the $n$-th level in $\T$}}$, we have $\I_{\T},
  w_\Data \models \varphi$, for each subformula $\varphi = \forall y_1
  \ldots \forall y_{\#(q)} ~.~ \stamp{q}{n-1}(\vec{y})
  \rightarrow \stamp{\psi}{n}$ of $\pathform{w_\Sigma}$, by the
  execution semantics of $\A$. This is the case because the children
  of each node labeled with $q(d_1,\ldots,d_{\#(q)})$ on the
  $(n-1)$-th level of $\T$ form a cube from
  $\cube{\minsem{\psi}_\nu}$, where $\nu$ is a valuation that assigns
  each $y_i$ the value $d_i$ and behaves like $w_\Data$,
  otherwise. Now supppose, for a contradiction, that $\I_{\T}$ is not
  minimal and let $\J \subsetneq \I_{\T}$ be an interpretation such
  that $\J,w_\Data \models \pathform{w_\Sigma}$. First, we show that
  the restriction $\J'$ of $\J$ to $\bigcup_{i=0}^{n-1} \stamp{Q}{i}$
  must coincide with $\I_{\G}$. Assuming this is not the case,
  i.e.\ $\J' \subsetneq \I_{\G}$, contradicts the minimality of
  $\I_{\G}$. Then the only possibility is that $\J(\stamp{q}{n})
  \subsetneq \I_{\T}(\stamp{q}{n})$, for some $q \in Q$. Let
  $p_1(y_1,\ldots,y_{\#(p_1)}) \arrow{a_n}{} \psi_1, \ldots,
  p_k(y_1,\ldots,y_{\#(p_k)}) \arrow{a_n}{} \psi_k$ be the set of
  transition rules in which the predicate symbol $q$ occurs on the
  right-hand side. Then it must be the case that, for some node on the
  $(n-1)$-th level of $\G$, labeled with a configuration
  $p_i(d_1,\ldots,d_{\#(p_i)})$, the set of children does not form a
  minimal cube from $\cube{\minsem{\stamp{\psi_i}{n}}}$, which
  contradicts the execution semantics of $\A$. \qed}

Next, we give a logical characterization of acceptance, relative to a
given sequence of input events $\alpha \in \Sigma^*$. To this end, we
extend the path formula $\pathform{\alpha}$ with a characterization of
the set of final states of $\A$: 
\begin{equation}\label{eq:accform}
\accform{\alpha} \isdef \pathform{\alpha} \wedge \bigwedge_{q
  \in Q \setminus F} \forall y_1 \ldots \forall y_{\#(q)} ~.~
\stamp{q}{n}(\vec{y}) \rightarrow \bot
\end{equation}
The top-level universal quantifiers from a subformula $\forall y_1
\ldots \forall y_{\#(q)} ~.~ \stamp{q}{i}(\vec{y}) \rightarrow \psi$
of $\accform{\alpha}$ will be referred to as \emph{path quantifiers},
in the following. Without loss of generality, path quantifiers are
assumed to be distinct from the transition quantifiers that occur
within a formula $\psi$ of a transition rule $q(y_1,\ldots,y_{\#(q)})
\arrow{a(X)}{} \psi$ of $\A$.

Observe that the acceptance formula $\accform{\A}$ is false in every
interpretation of the predicates that assigns a non-empty set to a
non-final predicate occurring on the last level in the execution
forest. The relation between the words accepted by $\A$ and the
acceptance formula above, is formally captured by the following lemma:

\begin{lemma}\label{lemma:acceptance}
  Given an automaton $\A = \tuple{\Sigma,X,Q,\iota,F,\Delta}$, for
  every word $w \in \Sigma[X]^*$, the following are
  equivalent: \begin{compactenum}
  \item\label{it1:lemma:acceptance} there exists an interpretation
    $\I$ such that $\I,w_\Data \models \accform{w_\Sigma}$, 
    %
  \item\label{it2:lemma:acceptance} $w \in \lang{\A}$. 
  \end{compactenum}
\end{lemma}
\proof{ ``$(\ref{it1:lemma:acceptance}) \Rightarrow
  (\ref{it2:lemma:acceptance})$'' Let $\I$ be an interpretation such
  that $\I,w_\Data \models \accform{w_\Sigma}$. By Lemma
  \ref{lemma:path-formula}, $\A$ has an execution $\T$ over $w$ such
  that $\I = \I_{\T}$. To prove that $\T$ is accepting, we show
  that \begin{inparaenum}[(i)]
    \item\label{it1:acceptance} all paths in $\T$ have length $n$ and
      that
    \item\label{it2:acceptance} the frontier of $\T$ is labeled with
      final configurations only. \end{inparaenum} First, assume that
  (\ref{it1:acceptance}) there exists a path in $\T$ of length $0 \leq
  m < n$. Then there exists a node on the $m$-th level, labeled with
  some configuration $q(d_1,\ldots,q_{\#(q)})$, that has no
  children. By the definition of the execution semantics of $\A$, we
  have $\cube{\minsem{\psi}_{\eta}} = \emptyset$, where
  $q(\vec{y}) \arrow{a_{m+1}(X)}{} \psi$ is the transition
  rule of $\A$ that applies for $q$ and $a_{m+1}$ and $\eta=
  w_\Data[y_1 \leftarrow d_1,\ldots,y_{\#(q)} \leftarrow
    d_{\#(q)}]$. Hence $\sem{\psi}_{\eta} = \emptyset$, and because
  $\I,w_\Data \models \accform{\alpha}$, we obtain that $\I,\eta \models
  q(\vec{y}) \rightarrow \stamp{\psi}{m+1}$, thus
  $\tuple{d_1,\ldots,d_{\#(q)}} \not\in \I(q)$. However, this
  contradicts the fact that $\I=\I_{\T}$ and that
  $q(d_1,\ldots,d_{\#(q)})$ labels a node of $\T$. Second, assume that
  (\ref{it2:acceptance}), there exists a frontier node of $\T$ labeled
  with a configuration $q(d_1,\ldots,d_{\#(q)})$ such that $q \in Q
  \setminus F$. Since $\I,w_\Data \models \forall y_1 \ldots \forall
  y_{\#(q)} ~.~ q(\vec{y}) \rightarrow \bot$, by a
  similar reasoning as in the above case, we obtain that
  $\tuple{d_1,\ldots,d_{\#(q)}} \not\in \I(q)$, contradiction.  

  ``$(\ref{it2:lemma:acceptance}) \Rightarrow
  (\ref{it1:lemma:acceptance})$'' Let $\T$ be an accepting execution
  of $\A$ over $w$. We prove that $\I_\T,w_\Data \models
  \accform{w_\Sigma}$. By Lemma \ref{lemma:path-formula}, we obtain
  $\I_\T,w_\Data \models \pathform{w_\Sigma}$. Since every path in
  $\T$ is of length $n$ and all nodes on the $n$-th level of $\T$ are
  labeled by final configurations, we obtain that $\I_\T,w_\Data
  \models \bigwedge_{q \in Q \setminus F} \forall y_1 \ldots \forall
  y_{\#(q)} ~.~ \stamp{q}{n}(\vec{y}) \rightarrow \bot$,
  trivially.  \qed}

As an immediate consequence, one can decide whether $\A$ accepts some
word $w$ with a given input sequence $w_\Sigma=\alpha$, by checking
whether $\accform{\alpha}$ is satisfiable. However, unlike
non-alternating infinite-state models of computation, such as counter
automata (nondeterministic programs with integer variables), the
satisfiability query for an acceptance (path) formula falls outside of
known decidable theories, supported by standard SMT solvers. There are
basically two reasons for this, namely \begin{inparaenum}[(i)]
\item the presence of predicate symbols, and
\item non-trivial alternation of quantifiers.
\end{inparaenum}
To understand this point, consider for example, the quantified theory
of Presburger arithmetic. Adding even only one monadic predicate
symbol to it yields undecidability in the presence of non-trivial
quantifier alternation \cite{Halpern91}, however the quantifier-free
fragment with predicate symbols is decidable\footnote{Linear integer
  arithmetic with uninterpreted function symbols is decidable, by a
  Nelson-Oppen style theory combination argument.}.

To tackle this problem, we start from the observation that acceptance
formulae have a particular form that allows the elimination of path
quantifiers and of predicates, by a couple of equivalence-preserving
transformations. The result will be a formula with no predicate
symbols, whose only quantifiers are the transition quantifiers
introduced by the transition rules of the automaton. We shall further
assume (\S\ref{sec:emptiness}) that the first-order theory of the data
sort $\Data$ has quantifier elimination, which allows to effectively
decide these queries. 

For the time being, let us formally define the elimination of
transition quantifiers and predicates, respectively. Given a sequence
of input events $\alpha = a_1 \ldots a_n$, consider the acceptance
formula: 
\[\accform{\alpha} = \stamp{\iota}{0} \wedge 
\bigwedge_{i=1}^n \bigwedge_{q(\vec{y}) \arrow{a_i(X)}{} \psi \in
  \Delta} \forall y_1 \ldots \forall y_{\#(q)} ~.~
\stamp{q}{i-1}(\vec{y}) \rightarrow \stamp{\psi}{i} \wedge
\bigwedge_{q \in Q \setminus F} \forall y_1 \ldots \forall y_{\#(q)}
~.~ \stamp{q}{n}(\vec{y}) \rightarrow \bot\]

\begin{definition}\label{def:quantform}
  Let $\quantformA{0}{\alpha}, \ldots, \quantformA{n}{\alpha}$ be the
  following sequence of formulae: \begin{compactitem}
  \item $\quantformA{0}{\alpha} \isdef \stamp{\iota}{0}$, 
  \item $\quantformA{i}{\alpha} \isdef \quantformA{i-1}{\alpha} \wedge
    \bigwedge \set{\stamp{q}{i-1}(t_1,\ldots,t_{\#(q)}) \rightarrow
      \stamp{\psi}{i}[t_1/y_1, \ldots, t_{\#(q)}/y_{\#(q)}] \mid
      \stamp{q}{i-1}(t_1,\ldots,t_{\#(q)}) \text{ occurs in }
      \quantformA{i-1}{\alpha}}$, for all $i \in [1,n]$.    
  \end{compactitem}
  We write $\quantform{\alpha}$ instead of $\quantformA{n}{\alpha}$,
  when no confusion arises.
\end{definition}
Observe that $\quantform{\alpha}$ contains no path quantifiers, as
required. On the other hand, the scope of zero or more transition
quantifiers might extend outside the formula given by the transition
rule, as shown by the following example: 

\begin{example}\label{ex:path-quant-elim}
  
\end{example}

\begin{definition}\label{def:substform}
Given a sequence of input events $\alpha = a_1 \ldots a_n$, let
$\substform{\alpha}$ be the formula obtained by successively replacing
in $\accform{\alpha}$: \begin{compactenum}[(a)]
\item\label{it1:substform} each occurrence of a predicate
  $\stamp{q}{i}(t_1,\ldots,t_{\#(q)})$ by the formula
  $\stamp{\psi}{i+1}[t_1/y_1,\ldots,t_{\#(q)}/y_{\#(q)}]$, where
  $q(\vec{y}) \arrow{a_{i+1}(X)}{} \psi \in \Delta$ is the transition
  rule for $q$ and $a_i$, for all $i=0,\ldots,n-1$,
%
\item\label{it2:substform} each occurrence of a predicate
  $\stamp{q}{n}$, such that $q \in Q \setminus F$, by $\top$, and
%
\item\label{it3:substform} each occurrence of a predicate
  $\stamp{q}{n}$, such that $q \in F$, by $\bot$.
\end{compactenum}
\end{definition}
Since there are no occurrences of predicates in $\substform{\alpha}$,
for each valuation $\nu : \stamp{X}{\leq n} \rightarrow \Data$, there
exists an interpretation $\I$ such that $\I,\nu \models
\substform{\alpha}$ if and only if $\J,\nu \models
\substform{\alpha}$, for every interpretation $\J$. Thus we omit $\I$
and simply write $\nu \models \substform{\alpha}$ in this case.

\begin{proposition}\label{prop:subst}
  Let $\phi$ be a positive formula and let $q(t_1,\ldots,t_{\#(q)})$
  be the only predicate atom occurring within $\phi$. Then, for every
  valuation $\nu$ of $\fv{}{\phi}$ and every formula $\psi$ with no
  predicate occurrences, the following are
  equivalent: \begin{compactenum}
  \item\label{it1:prop:subst} $\nu \models \phi[\psi[t_1/y_1, \ldots,
      t_{\#(q)}/y_{\#(q)}]/q(t_1,\ldots,t_{\#(q)})]$, 
    %
  \item\label{it2:prop:subst} $\I,\nu \models \phi \wedge \forall y_1
    \ldots \forall y_{\#(q)} ~.~ q(\vec{y}) \rightarrow
    \psi$, for some interpretation $\I$.
  \end{compactenum}
  where $y_1,\ldots,y_{\#(q)} \not\in \fv{}{\phi}$. 
\end{proposition}
\proof{ We give the proof in the case $\phi$ is quantifier-free. The
  generalization to a non-empty quantifier prefix is straightforward.
  ``$(\ref{it1:prop:subst}) \Rightarrow (\ref{it2:prop:subst})$'' We
  distinguish two cases:
  \begin{compactitem}
  \item if $\nu \models \psi[t_1/y_1, \ldots, t_{\#(q)}/y_{\#(q)}]$
    then let $\I(q) = \set{\tuple{t_1^\nu,\ldots,t_{\#(q)}^\nu}}$ and
    $\emptyset$ everywhere else. We have $\I,\nu \models
    q(t_1,\ldots,t_{\#(q)})$ and, since $\phi$ is positive, replacing
    $\psi[t_1/y_1, \ldots, t_{\#(q)}/y_{\#(q)}]$ with
    $q(t_1,\ldots,t_{\#(q)})$ in $\phi$ does not change its
    satisfiability under $\I,\nu$, hence $\I,\nu \models
    \phi$. Moreover, $\nu \models \psi[t_1/y_1, \ldots,
      t_{\#(q)}/y_{\#(q)}]$ thus $\I,\nu \models \forall y_1 \ldots
    \forall y_{\#(q)} ~.~ q(\vec{y}) \rightarrow \psi$.
    %
  \item else $\nu \not\models \psi[t_1/y_1, \ldots,
    t_{\#(q)}/y_{\#(q)}]$ and let $\I$ be the interpretation assigning
    each predicate symbol with $\emptyset$. Then replacing
    $\psi[t_1/y_1, \ldots, t_{\#(q)}/y_{\#(q)}]$ with
    $q(t_1,\ldots,t_{\#(q)})$ in $\phi$ does not change its
    satisfiability under $\I,\nu$. Moreover, since $\I$ maps $q$ to
    $\emptyset$, we have $\I,\nu \models \forall y_1 \ldots \forall
    y_{\#(q)} ~.~ q(\vec{y}) \rightarrow \psi$, trivially.
  \end{compactitem}

  ``$(\ref{it2:prop:subst}) \Rightarrow (\ref{it1:prop:subst})$'' We
  distinguish two cases: \begin{compactitem}
  \item if $\tuple{t_1^\nu, \ldots, t_{\#(q)}^\nu} \in \I(q)$, since
    $\I,\nu \models \forall y_1 \ldots \forall y_{\#(q)} ~.~
    q(\vec{y}) \rightarrow \psi$, we have $\nu \models
    \psi[t_1/y_1,\ldots,t_{\#(q)}/y_{\#(q)}]$. Since $\phi$ is
    positive, replacing $q(t_1,\ldots,t_{\#(q)})$ by $\psi$ in $\phi$
    does not change its satisfiability under $\nu$, hence $\nu \models
    \phi[\psi[t_1/y_1, \ldots, t_{\#(q)}/y_{\#(q)}]/q(t_1, \ldots,
      t_{\#(q)})]$.
    %
  \item else $\tuple{t_1^\nu, \ldots, t_{\#(q)}^\nu} \not\in \I(q)$,
    that is $\I,\nu \not\models q(t_1,\ldots,t_{\#(q)})$. Then $\nu
    \models \phi[\bot/q(t_1,\ldots,t_{\#(q)})]$ and we obtain $\nu
    \models \phi[\psi[t_1/y_1, \ldots, t_{\#(q)}/y_{\#(q)}]/q(t_1,
      \ldots, t_{\#(q)})]$, because $\phi$ is positive, thus
    $\phi[\bot/q(t_1,\ldots,t_{\#(q)})] \models \phi[\psi[t_1/y_1,
        \ldots, t_{\#(q)}/y_{\#(q)}]/q(t_1, \ldots, t_{\#(q)})]$. \qed
  \end{compactitem}}

\begin{lemma}\label{lemma:substitution}
  Given an automaton $\A = \tuple{\Sigma,X,Q,\iota,F,\Delta}$, for
  every word $w \in \Sigma[X]^*$, we have $w_\Data \models
  \substform{w_\Sigma}$ if and only if $w \in \lang{\A}$.
\end{lemma}
\proof{ By Lemma \ref{lemma:acceptance}, $w \in \lang{\A}$ if and only
  if $\I,w_\Data \models \accform{w_\Sigma}$, for some interpretation
  $\I$. By induction on the number of predicate atoms in
  $\accform{w_\Sigma}$, using Proposition \ref{prop:subst} in the
  inductive step, we prove that, $\I,w_\Data \models
  \accform{w_\Sigma}$ if and only if $w_\Data \models
  \substform{w_\Sigma}$. \qed}

\subsection{Closure Properties}
\label{sec:closure}

Given a positive formula $\phi$, we define the \emph{dual} formula
$\dual{\phi}$ recursively as follows:
\[\begin{array}{rclcrclcrcl}
\dual{(\phi_1 \vee \phi_2)} & = & \dual{\phi_1} \wedge \dual{\phi_2} && 
\dual{(\phi_1 \wedge \phi_2)} & = & \dual{\phi_1} \wedge \dual{\phi_2} &&
\dual{(t \teq s)} & = & \neg(t \teq s) \\
\dual{(\exists x ~.~ \phi_1)} & = & \forall x ~.~ \dual{\phi_1} && 
\dual{(\forall x ~.~ \phi_1)} & = & \exists x ~.~ \dual{\phi_1} && 
\dual{(\neg(t \teq s))} & = & t \teq s \\
\dual{(q(x_1,\ldots,x_{\#(q)}))} & = & q(x_1,\ldots,x_{\#(q)})
\end{array}\]
Observe that, because predicate atoms do not occur negated in $\phi$,
there is no need to define dualization for formulae of the form $\neg
q(x_1,\ldots,x_{\#(q)})$. The following theorem shows closure of
automata under all boolean operations:

%% The dualization operation has the following property:
%% \begin{lemma}\label{lemma:dual}
%%   Given a formula $\phi$ and an automaton
%%   $\A=\tuple{\Sigma,X,Q,\iota,F,\Delta}$, we have the equivalence
%%   $\Accept{F}{\phi} \equiv \neg(\dual{\Accept{Q\setminus F}{\phi}})$. 
%% \end{lemma}
%% \proof{ By straightforward induction on the structure of $\phi$. \qed}

\begin{theorem}\label{thm:closure}
  Given automata $\A_i = \tuple{\Sigma,X,Q_i,\iota_i,F_i,\Delta_i}$,
  for $i=1,2$, such that $Q_1 \cap Q_2 = \emptyset$, the following hold: 
  \begin{compactenum}
    \item\label{it1:thm:closure} $\lang{\A_\cap} = \lang{\A_1} \cap \lang{\A_2}$, where
      $\A_\cap = \tuple{\Sigma,X,Q_1 \cup Q_2, \iota_1 \wedge \iota_2,
      F_1 \cup F_2, \Delta_1 \cup \Delta_2}$, 
      %
    \item\label{it2:thm:closure} $\lang{\overline{\A_i}} = \Sigma[X]^*
      \setminus \lang{\A_i}$, where $\overline{\A_i} =
      \tuple{\Sigma,X,Q_i,\dual{\iota},Q_i\setminus
        F_i,\dual{\Delta}_i}$ and, for $i=1,2$: \[\dual{\Delta}_i =
      \set{q(\vec{y}) \arrow{a(X)}{} \dual{\psi} \mid
        q(\vec{y}) \arrow{a(X)}{} \psi \in
        \Delta_i}\enspace.\]
  \end{compactenum}
  Moreover, $\len{\A_\cap} = \bigO{\len{\A_1}+\len{\A_2}}$ and
  $\len{\overline{\A_i}} = \bigO{\len{\A_i}}$, for all $i=1,2$.
\end{theorem}
\proof{ (\ref{it1:thm:closure}) ``$\subseteq$'' Let $w \in
  \lang{\A_\cap}$ be a word and $\T$ be an execution of $\A_\cap$ over
  $w$. Since $Q_1 \cap Q_2 = \emptyset$, it is possible to partition
  $\T$ into $\T_1$ and $\T_2$ such that the roots of $\T_i$ form a
  cube from $\cube{\minsem{\iota_i}}$, for all $i=1,2$. Because
  $\Delta_1 \cap \Delta_2 = \emptyset$, by induction on
  $\len{w}\geq0$, one shows that $\T_i$ is an execution of $\A_i$ over
  $w$, for all $i=1,2$. Finally, because $\T$ is accepting, we obtain
  that $\T_1$ and $\T_2$ are accepting, respectively, hence $w \in
  \lang{\A_1} \cap \lang{\A_2}$. ``$\supseteq$'' Let $w \in
  \lang{\A_1} \cap \lang{\A_2}$ and let $\T_i$ an accepting execution
  of $\A_i$ over $w$, for all $i=1,2$. We show that $\T_1 \cup \T_2$
  is an execution of $\A_\cap$ over $w$, by induction on
  $\len{w}\geq0$. For the base case $\len{w}=0$, we have $\T_i \in
  \cube{\minsem{\iota_i}}$ for all $i=1,2$ and since $Q_1 \cap Q_2 =
  \emptyset$, we have $\T_1 \cup \T_2 \in \cube{\minsem{\iota_1 \wedge
      \iota_2}}$. The induction step follows as a consequence of the
  fact that $\Delta_1 \cup \Delta_2$ is the set of transition rules of
  $\A_\cap$. Finally, since both $\T_1$ and $\T_2$ are accepting,
  $\T_1 \cup \T_2$ is accepting as well. Moreover, we have: 
  \[
  \len{\A_\cap} = \len{\iota_1 \wedge \iota_2} + \sum_{q(\vec{y})
    \arrow{a(X)}{} \psi \in \Delta_1 \cup \Delta_2} \len{\psi} =
  1 + \len{\iota_1} + \len{\iota_2} + \sum_{q(\vec{y})
    \arrow{a(X)}{} \psi \in \Delta_1} \len{\psi} + \sum_{q(\vec{y})
    \arrow{a(X)}{} \psi \in \Delta_2} \len{\psi} \enspace. 
  \]

  \noindent(\ref{it2:thm:closure}) Let $w \in \Sigma[X]^*$ be a
  word. We denote by $\accformA{\A_1}{w_\Sigma}$ and
  $\substformA{\A_1}{w_\Sigma}$
  [resp. $\accformA{\overline{\A}_1}{w_\Sigma}$ and
    $\substformA{\overline{\A}_1}{w_\Sigma}$] the formulae
  $\accform{w_\Sigma}$ and $\substform{w_\Sigma}$ for $\A_1$ and
  $\overline{\A}_1$, respectively. It is enough to show that
  $\substformA{\overline{\A}_1}{w_\Sigma} =
  \neg\substformA{\A_1}{w_\Sigma}$ and apply Lemma
  \ref{lemma:substitution} to prove that $w \in \lang{\A_1} \iff w
  \not\in \lang{\overline{\A}_1}$. Since the choice of $w$ was
  arbitrary, this proves $\lang{\overline{\A}_1} = \Sigma[X]^*
  \setminus \lang{\A_1}$. By induction on the number of predicate
  atoms in $\accformA{\A_1}{w_\Sigma}$ that are replaced during the
  generation of $\substformA{\A_1}{w_\Sigma}$. The proof relies on the
  following fact:

  \begin{fact}\label{fact:dual-neg}
    Let $\phi$ be a positive formula and let $q(t_1,\ldots,t_{\#(q)})$
    be the only occurrence of a predicate symbol within $\phi$. Then,
    every formula $\phi$ with no predicate occurrences:
    $\neg\phi[\psi[t_1/y_1,\ldots,t_{\#(q)}/y_{\#(q)}]/q(t_1,\ldots,t_{\#(q)})]
    \equiv
    \dual{\phi}[\neg\psi[t_1/y_1,\ldots,t_{\#(q)}/y_{\#(q)}]/q(t_1,\ldots,t_{\#(q)})]$.
  \end{fact}
  \proof{By induction on the structure of $\phi$. \qed}}

\section{The Emptiness Problem}
\label{sec:emptiness}

The problem of checking emptiness of a given automata is undecidable,
even for automata with predicates of arity two whose transition rules
use only equalities and disequalities, with no quantifiers
\cite{Farzan15}. Since even such simple classes of alternating
automata have no general decision procedure, we use an
abstraction-refinement semi-algorithm based on \emph{lazy annotation}
\cite{McMillan06,McMillan14}. In a nutshell, a lazy annotation
procedure systematically explores the set of execution traces of a
program in search for a counterexample. When a spurious counterexample
is found, the search backtracks and the program path is annotated with
a set of learned facts, that excludes the path from future
searches. These facts are interpolants extracted from the proof of
spuriousness of the given (finite) path.

Typically, when checking the unreachability of a set of program
configurations (or, more generally, the infeasability of a set of Horn
clauses \cite{BjornerGurfinkelMcMillanRybalchenko15}), the
interpolants used to annotate the unfolded control structure are local
assertions about the values of the program variables in a given
control state. These assertions define inductive overapproximations of
the set of configurations reachable at that control state, that
suffice to prove emptiness or, equivalently, a safety property of the
system.

When considering an alternating model of computation, local
interpolants that involve a single control state are no longer enough,
because of the synchronization of several branches of the computation
on the same sequence of input values. Consider, for instance, an
automaton with the following transition rules and final state $q_f$:
\[\begin{array}{rclcrcl}
q_0(y) & \arrow{a(x)}{} & q_1(y+x) \wedge q_2(y-x) & \hspace*{2mm} & 
q_1(y) \arrow{a(x)}{} y+x > 0 \wedge q_f \\
q_1(y) & \arrow{a(x)}{} & q_1(y+x) && q_2(y) \arrow{a(x)}{} y-x > 0 \wedge q_f \\
q_2(y) & \arrow{a(x)}{} & q_2(y-x)
\end{array}\]
Started in an initial configuration $q_0(0)$ with an input word
$(a,\nu_1) \ldots (a,\nu_{n-1}) (b,\nu_n)$, such that $\nu_i(x)=k_i$,
the automaton executes as follows:
\[\begin{array}{l}
q_0(0) \arrow{(a,\nu_1)}{} q_1(k_1)
\wedge q_2(-k_1) \ldots \arrow{(a,\nu_{n-1})}{} 
q_1(\sum_{i=1}^{n-1} k_i) \wedge q_2(-\sum_{i=1}^{n-1} k_i) \arrow{(a,\nu_n)}{} \\
\sum_{i=1}^{n} k_i > 0 \wedge \sum_{i=1}^{n} k_i < 0 \wedge q_f \equiv \bot
\end{array}\] 
An overapproximation of the set of cubes generated after one or more
steps is defined by the formula: $\exists x_1 \exists x_2 ~.~ q_1(x_1)
\wedge q_2(x_2) \wedge x_1+x_2 \teq 0$. Observe that a formula using
one occurrence of a predicate would give a too rough overapproximation
of this set, unable to prove the emptiness of the automaton.

The solution we adopt is a generalization of the classical approach of
extracting the interpolants from the proof of unsatisfiability of a
time-stamped path formula. Given a sequence of input events $\alpha$,
we consider the path formula $\accform{\alpha}$, constrained by the
fact that all non-final predicates $\stamp{q}{\len{\alpha}}$ must be
empty sets, defined as in (\ref{eq:accform}). If this formula is
unsatisfiable, we show the existence of a sequence of (possibly
quantified) positive interpolants that overapproximate the set of
cubes generated at each step during an execution over a word $w$,
whose even sequence is $w_\Sigma = \alpha$. Moreover, these
interpolants are local, in the sense that each formula uses only the
values of the variables and the state predicates stamped with its
index in the sequence.

Unlike with the classical path formulae for integer programs
\cite{McMillan06} and Horn clauses
\cite{BjornerGurfinkelMcMillanRybalchenko15}, that are expressed using
linear or Presburger arithmetic, the existence of local interpolants
for theories using first-order predicates relies on a non-constructive
argument, the Lyndon Interpolation Theorem \cite{Lyndon59}. Since
usual decidable theories, such as Presburger arithmetic, become
undecidable in the presence of monadic predicate symbols
\cite{Halpern91}, we cannot hope to find an automated interpolant
generation method, in general.

But here is where the predicate-free path formulae (Definition
\ref{def:substform}) come into play. For a given event sequence
$\alpha$, the automaton $\A$ accepts a word $w$ such that $w_\Sigma =
\alpha$ if and only if $\substform{\alpha}$ is satisfiable (Lemma
\ref{lemma:substitution}). Assuming further that the equality atoms in
the transition rules of $\A$ are written in the language of a
decidable first-order theory, such as Presburger arithmetic, Lemma
\ref{lemma:substitution} gives us an effective way of checking
emptiness of $\A$ relative to a given event sequence. However, this
method does not cope well with lazy annotation, because there is no
way to extract, from the unsatisfiability proof of
$\substform{\alpha}$, the interpolants needed to annotate
$\alpha$. This is because \begin{inparaenum}[(i)]
\item the formula $\substform{\alpha}$, obtained by repeated
  substitutions (Definition \ref{def:substform}) loses track of the
  execution semantics of $\A$, and 
%
\item quantifiers may occur nested in $\substform{\alpha}$, making it
  difficult to write $\substform{\alpha}$ as a proper interpolation
  problem.
\end{inparaenum}

The solution we adopt in this paper relies on an additional assumption
related to the decidability of the predicate-free theory in which
$\substform{\alpha}$ formulae are written, namely that the theory has
an effective \emph{witness-providing quantifier elimination}
procedure. More precisely, we assume that, for each formula $\exists x
~.~ \phi(x)$, there exists an effectively computable term $t$, in
which $x$ does not occur, such that $\exists x ~.~ \phi$ and
$\phi[t/x]$ are equi-satisfiable. These terms, called \emph{witnesses}
in the following, are actual interpretations of the Skolem function
symbols from the following folklore theorem:

\begin{theorem}\label{thm:skolem}
  Given $Q_1 x_1 \ldots Q_n x_n ~.~ \phi$ a first order sentence, 
  where $Q_1, \ldots, Q_n \in \set{\exists,\forall}$ and $\phi$ is
  quantifier-free, let: 
  \[\eta_i \equiv \left\{\begin{array}{ll}
  f_i(y_1,\ldots,y_{k_i}) & \text{if } Q_i \equiv \forall \\
  x_i & \text{if } Q_i \equiv \exists
  \end{array}\right.\]
  where $f_i$ is a fresh function symbol and $\set{y_1, \ldots,
    y_{k_i}} = \set{x_j \mid j < i,~ Q_j \equiv \exists}$. Then \(Q_1
  x_1 \ldots Q_n x_n ~.~ \phi \rightarrow
  \phi[\eta_1/x_1,\ldots,\eta_n/x_n]\) is valid.
\end{theorem}
\proof{See \cite[Theorem 2.1.8]{BorgerGraedelGurevich97} and
  \cite[Lemma 2.1.9]{BorgerGraedelGurevich97}. \qed}
Observe that our assumption on the existence of an effective
witness-providing quantifier elimination procedure is stronger than
the above theorem, as we require that \begin{inparaenum}[(i)] 
\item the $f_i$ functions be definable in the language of the theory,
  and 
\item $Q_1 x_1 \ldots Q_n x_n ~.~ \phi$ and
  $\phi[\eta_1/x_1,\ldots,\eta_n/x_n]$ are equi-satisfiable. 
\end{inparaenum}
Among the theories that support witness-providing quantifier
elimination, one mentions \comment[ri]{LIA, LRA, Presburger, Tarski?,
  BAPA?}

Turning back to the problem of generating interpolants from the proof
of unsatisfiability of a path formula $\accform{\alpha}$, assume that
the equivalent predicate-free formula $\substform{\alpha} = \exists
x_1 \forall y_1 \ldots \exists x_n \forall y_n ~.~ \psi$ is
unsatisfiable and let $t_1(x_1)$, $\ldots, t_n(x_1,\ldots,x_n)$ be
witnesses such that $\psi[t_1/y_1,\ldots,t_n/y_n] \equiv \bot$. Then
we show that the quantifier-free formula (with predicates) obtained
from $\accform{\alpha}$ by (roughly) replacing the universal
quantifiers with $t_1, \ldots, t_n$ in $\accform{\alpha}$ is also
unsatisfiable.  Moreover, this new formula is layered in the same way
as $\accform{\alpha}$, namely as a conjunction of the form:
\[\stamp{\iota}{0} \wedge \bigwedge_{i=1}^n \bigwedge_{q(\vec{y})
  \arrow{a_i(X)}{} \psi \in \Delta} \stamp{q}{i-1}(\vec{t}_{q,i-1})
\rightarrow \stamp{\psi}{i} \wedge \bigwedge_{q \in Q \setminus F}
\stamp{q}{n}(\vec{t}_{q,n}) \rightarrow \bot\]


\comment[ri]{i am here}

However, the existence of a decision procedure for the theory in which
$\accform{\alpha}$ is written is not guaranteed, as it was usually the
case of classical path formulae for integer programs \cite{McMillan06}
and Horn clauses \cite{BjornerGurfinkelMcMillanRybalchenko15} using
linear or Presburger arithmetic. The problem is mainly that decidable
theories, such as Presburger arithmetic become undecidable in the
presence of monadic predicate symbols \cite{Halpern91}. A way around
this problem is to check whether a given event sequence $\alpha$ may 



The rest of this section is concerned with defining the building
blocks of a lazy annotation semi-algorithm for checking emptiness of
automata. 

In particular, we address the following problems: \begin{compactenum}
%
\item generation of interpolants that prove the infeasability of a
  given path formula, assuming the decidability of the first-order
  theory in which the path formulae are written. 
%
\item generation of non-local interpolants using history variables,
  obtained by Skolemization of the universal quantifiers that occur
  within transition rules.
%
\item computing the coverage between two node labels in the unfolding
  of an automaton, when history variables occur. 
\end{compactenum} 
Based on these results, we show how a version of the classical
\textsc{Impact} \cite{McMillan06} semi-algorithm can be used to
(dis-)prove the emptiness of first-order alternating automata. 

\subsection{Lyndon Interpolants}

Let $\phi$ and $\psi$ be first-order formulae, such that $\phi \wedge
\psi$ is unsatisfiable. The \emph{vocabulary} of $\phi$, denoted as
$\voc{\phi}$, is the set of function symbols that occur in $\phi$.  By
$\pset{+}{\phi}$ [$\pset{-}{\phi}$] we denote the set of predicate
symbols that occur in $\phi$ under an even (odd) number of
negations. A \emph{Lyndon interpolant} \cite{Lyndon59} for $\phi$ and
$\psi$ is a first-order formula $I$ such that: \begin{compactitem}
\item $\phi \rightarrow I$ is valid,  
\item $I \wedge \psi$ is unsatisfiable, 
\item $\voc{I} \subseteq \voc{\phi} \cap \voc{\psi}$, 
\item $\pset{+}{I} \subseteq \pset{+}{\phi} \cap \pset{+}{\psi}$ and
  $\pset{-}{I} \subseteq \pset{-}{\phi} \cap \pset{-}{\psi}$.
\end{compactitem}
The existence of Lyndon interpolants for first-order logic was proved
by a non-constructive model-theoretic argument \cite{Lyndon59}. For
now, we silently assume that the satisfiability problem for the theory
in which $\phi$ and $\psi$ are written is decidable and, moreover,
that a decision procedure generating Lyndon interpolants exists, for
this theory. This is a rather unrealistic assumption, given that
classical decidable theories, such as Presburger arithmetic, become
undecidable in the presence of (monadic) predicate symbols
\cite{Halpern91}.

Let $\A = \tuple{\Sigma,X,Q,\iota,F,\Delta}$ be an automaton for the
rest of this section. Given a non-empty sequence of input events
$\alpha = a_1 \ldots a_n \in \Sigma^*$, a \emph{local interpolant} for
$\alpha$ is a sequence $I_0,I_1,\ldots,I_n$ of first-order formulae
such that: \begin{compactitem}
\item $\iota \rightarrow I_0$ is valid, 
%
\item $\left[I_k \wedge \left(\bigwedge_{q(\vec{y}_q) \arrow{a_i(X)}{} \psi}
  \forall \vec{y}_q ~.~ \stamp{q}{k}(\vec{y}_q) \rightarrow
  \nextf{\psi}\right)\right] \rightarrow \nextf{I}_{k+1}$ is valid, for all $k \in [n-1]$,
%
\item $I_n \wedge \left(\bigwedge_{q \in Q \setminus F} \forall \vec{y}_q
  ~.~ q(\vec{y}_q) \rightarrow \bot\right)$ is unsatisfiable,
%
\item $\voc{I_k} = \pset{+}{I_k}$ and $\pset{-}{I_k} = \emptyset$. 
\end{compactitem}

\begin{lemma}\label{lemma:lyndon-existence}
  
\end{lemma}

\subsection{Skolem Witnesses} 

\subsection{Lazy Annotation} 


Assuming that the data domain is countable, the set of finite words
$\Sigma[X]^*$ is countable and the emptiness problem is recursively
enumerable. Moreover, by Lemma \ref{lemma:acceptance}, a systematic
enumeration of sequences of input events $\alpha \in \Sigma^*$ will
eventually discover an accepted word, provided that all path formulae
$\pathform{\alpha}$ belong to a decidable first-order theory.




However, if the automaton is empty, the enumeration of input event
sequences will fail to terminate, in general. The classical way to
fight this divergence problem is to consider a \emph{coverage} partial
order, which is a subset of the following relation: 

\begin{definition}\label{def:coverage}
  Given an automaton $\A = \tuple{\Sigma,X,Q,\iota,F,\Delta}$ and
  $S_1, S_2 \subseteq \bigcup_{q \in Q} \set{q(d_1,\ldots,d_{\#(q)})
    \mid d_1,\ldots,d_{\#(q)} \in \Data}$, we have $S_1 \sqsubseteq
  S_2$ if and only if 
  \begin{equation}\label{eq:po}
    \text{
      \begin{minipage}{0.7\textwidth}
        $\A$ accepts a word $w$ when started in a set of cubes $C_1
        \in S_1$ only if $\A$ accepts $w$ when started in a set of
        cubes $C_2 \in S_2$.
    \end{minipage}} 
  \end{equation}
\end{definition}
Since, in general the $\sqsubseteq$ relation is not definable using
available decidable (SMT) theories, we consider the following stronger
relation: $S_1 \supsetforex S_2$ if and only if, for each set of cubes
$C_1 \in S_1$, there exists a set of cubes $C_2 \in S_2$ such that
$C_1 \supseteq C_2$.

\begin{lemma}\label{lemma:coverage}
  Given an automaton $\A = \tuple{\Sigma,X,Q,\iota,F,\Delta}$, for any
  sets of cubes $S_1, S_2 \subseteq \bigcup_{q \in Q}
  \set{q(d_1,\ldots,d_{\#(q)}) \mid d_1,\ldots,d_{\#(q)} \in \Data}$
  such that $S_1 \supsetforex S_2$, we have $S_1 \sqsubseteq S_2$.
\end{lemma}
\proof{  
\qed}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{abbrv} \bibliography{refs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
