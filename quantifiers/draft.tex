\documentclass{llncs}
% \documentclass[10pt,conference,letterpaper,twocolumn]{IEEEtran}

\usepackage[usenames,dvipsnames]{color}

\usepackage{latexsym}
\usepackage{amsxtra} 
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{pslatex}
\usepackage{epsfig}
\usepackage{wrapfig}
\usepackage{paralist}
% \usepackage{stmaryrd}
\usepackage{txfonts}
\usepackage{framed}
\usepackage{makecell}
\usepackage{url}
\usepackage{tikz}
\usetikzlibrary{automata,positioning, calc}
\usepackage[inline,shortlabels]{enumitem}

\usepackage{proof}

\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}

\usepackage[draft]{commenting}

\pagestyle{plain}

\include{commands-lncs}

\declareauthor{ri}{Radu}{blue}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{First Order Alternation}

\author{Radu Iosif and Xiao Xu}
\institute{
  CNRS, Verimag, Universit\'e de Grenoble Alpes \\
  Email: \{Radu.Iosif,Xiao.Xu\}@univ-grenoble-alpes.fr
}

\maketitle

\begin{abstract}
\end{abstract}

\section{Preliminaries}

For two integers $0 \leq i \leq j$, we denote by $[i,j]$ the set
$\set{i,i+1,\ldots,j}$ and by $[i]$ the set $[1,i]$, where $[0]$ is
the empty set.

A \emph{signature} $\sig = (\ssorts{\sig},\sfuns{\sig})$ consists of a
set $\ssorts{\sig}$ of \emph{sort symbols} and a set $\sfuns{\sig}$ of
sorted \emph{function symbols}. To simplify the presentation, we
assume w.l.o.g. that $\ssorts{\sig} = \set{\Data,\Bool}$\footnote{The
  generalization to more than two sorts is without difficulty, but
  would unnecessarily clutter the technical presentation.} and each
function symbol $f \in \sfuns{\sig}$ has $\#(f) \geq 0$ arguments of
sort $\Data$ and return value of sort $\sort{f}$, which can be either
$\Bool$ or $\Data$. If $\#(f)=0$ then $f$ is a \emph{constant} and we
denote by $\top$ and $\bot$ the only constants of sort $\Bool$,
representing the true and false values, respectively. We write $\preds
= \set{f \in \sfuns{\sig} \mid \sort{f} = \Bool}$ for the set of
boolean function symbols, also called \emph{predicates} in the
following.

We consider an infinite countable set of \emph{variables} $\vars$,
where each $x \in \vars$ has an associated sort, denoted $\sort{x}$. A
\emph{term} $t$ of sort $\sort{t}$ is either a variable $x \in \vars$
of sort $\sort{t}$, or $f(t_1,\ldots,t_{\#(f)})$ where
$t_1,\ldots,t_{\#(f)}$ are terms of sort $\Data$ and
$\sort{f}=\sort{t}$. An \emph{atom} is a term
$p(t_1,\ldots,t_{\#(p)})$ of sort $\Bool$, or an equality $t \teq s$
between two terms of sort $\Data$. A \emph{formula} is a possibly
quantified boolean combination of atoms and a \emph{sentence} is a
formula in which each variable occurs under the scope of a quantifier.
A formula is \emph{positive} if and only if each predicate occurs
under an even number of negations. 

We denote by $\fv{\sigma}{\phi}$ the set of free variables of sort
$\sigma$ in $\phi$ and write $\fv{}{\phi}$ for $\bigcup_{\sigma \in
  \ssorts{\sig}} \fv{\sigma}{\phi}$. For a variable $x \in
\fv{}{\phi}$ and a term $t$ such that $\sort{t} = \sort{x}$, let
$\phi[t/x]$ be the result of replacing each occurrence of $x$ by
$t$. For indexed sets $T=\set{t_1,\ldots,t_n}$ and
$X=\set{x_1,\ldots,x_n}$, where $\sort{t_i} = \sort{x_i}$, we write
$\phi[T/X]$ for the formula obtained by simultaneously replacing $x_i$
with $t_i$ in $\phi$, for all $i\in[n]$. The size $\len{\phi}$ is the
number of symbols occuring in $\phi$.

An \emph{interpretation} $\I$ maps \begin{inparaenum}[(1)]
\item the sort $\Data$ into a non-empty set $\Data^\I$, 
%
\item the sort $\Bool$ into the set $\booli = \set{\true,\false}$, where
  $\top^\I = \true$, $\bot^\I = \false$, and
%
\item each function symbol $f$ into a total function $f^\I :
  \left(\Data^\I\right)^{\#(f)} \rightarrow \sort{f}^I$, or an element
  of $\sort{f}^I$ when $\#(f)=0$.
\end{inparaenum}
Given an interpretation $\I$, a \emph{valuation} $\nu$ maps each
variable $x \in \vars$ into an element of $x_\sigma^\I$. For a term
$t$, we denote by $t^\I_\nu$ the value obtained by replacing each
function symbol $f$ by its interpretation $f^\I$ and each variable $x$
by its valuation $\nu(x)$. For a formula $\phi$, we write $\I,\nu
\models \phi$ if the formula obtained by replacing each term $t$ in
$\phi$ by the value $t^\I_\nu$ is logically equivalent to true.  The
semantics of quantifiers is given as usual: $\I,\nu \models \exists x
~.~ \phi$ if and only if $\I,\nu[x \leftarrow u] \models \phi$, for
some value $u \in \sort{x}^\I$, where $\nu[x \leftarrow u]$ is the
valuation that assigns $u$ to $x$ and $\nu(y)$ to all $y \neq x$.

A formula $\phi$ is \emph{satisfiable} in the interpretation $\I$ if
there exists a valuation $\nu$ such that $\I,\nu \models \phi$, and
\emph{valid} if $\I,\nu \models \phi$ for all valuations $\nu$.  The
\emph{first-order theory} $\theory(\sig,\I)$ is the set of valid
formulae written in the signature $\sig$, with the interpretation
$\I$. A \emph{decision procedure} for $\theory(\sig,\I)$ is an
algorithm that takes a formula $\phi$ in the signature $\sig$ and
returns yes if and only if $\phi \in \theory(\sig,\I)$.

Given formulae $\varphi$ and $\psi$, we say that \emph{$\phi$ entails
  $\psi$ modulo $\theory(\sig,\I)$}, denoted $\phi
\models_{\theory(\sig,\I)} \psi$ iff $\varphi \rightarrow \psi \in
\theory(\sig,\I)$. We say that $\varphi$ and $\psi$ are
\emph{$\theory(\sig,\I)$-equivalent}, denoted $\phi
\equiv_{\theory(\sig,\I)} \psi$ iff $\phi \models_{\theory(\sig,\I)}
\psi$ and $\psi \models_{\theory(\sig,\I)} \phi$. The theory
$\theory(\sig,\I)$ has \emph{quantifier elimination} iff for any
formula $\exists x ~.~ \phi(x)$, where $\phi$ is quantifier-free,
there exists a quantifier free formula $\psi$ such that $\phi$ and
$\psi$ are $\theory(\sig,\I)$-equivalent.

\section{First Order Alternating Data Automata}

In the rest of the paper, we we fix a theory $\theory(\sig,\I)$ and
omit mentioning it in the context of entailments and equivalences. Let
$\Sigma$ be a finite alphabet $\Sigma$ of \emph{input events}. Given a
finite set $X \subset \vars$ of variables of sort $\Data$, we denote
by $X \mapsto \Data^\I$ the set of valuations of the variables $X$ and
$\Sigma[X] = \Sigma \times (X \mapsto \Data^\I)$ be the possibly
infinite set of \emph{data symbols}. A \emph{data word} (word in the
sequel) is a finite sequence $(a_1,\nu_1)(a_2,\nu_2) \ldots
(a_n,\nu_n)$ of data symbols, where $a_1,\ldots,a_n \in \Sigma$ and
$\nu_1,\ldots,\nu_n : X \rightarrow \Data^\I$ are valuations. We
denote by $\varepsilon$ the empty sequence, by $\Sigma^*$ the set of
finite sequences of input events and by $\Sigma[X]^*$ the set of data
words over the variables $X$.

A \emph{first-order alternating data automaton} (automaton in the
sequel) is a tuple $\A = \tuple{\Sigma,X,Q,\iota,F,\Delta}$, where
$\Sigma$ is the finite event alphabet, $X$ is a
finite set of variables, $Q \subseteq \preds$ is a finite set of
\emph{state predicates}, $\iota$ is a sentence, $F \subseteq Q$ is a
set of \emph{final states} and $\Delta$ is a set of \emph{transition
  rules} of the form:
\[q(y_1,\ldots,y_{\#(q)}) \arrow{a(X)}{} \psi\]
where $q \in Q$, $a \in \Sigma$, $\psi$ is a positive formula such
that $\fv{}{\phi} \subseteq X \cup \set{y_1,\ldots,y_{\#(q)}}$, $X
\cap \set{y_1,\ldots,y_{\#(q)}} = \emptyset$ and each predicate that
occurs in $\psi$ belongs also to $Q$. We stress the fact that each
predicate occurs in $\psi$ under an even number of negations.

Intuitively, $a$ is the input event and $X$ are the input data values
that trigger the transition, whereas $q$ and $y_1,\ldots,y_{\#(q)}$
are the current control state and data values pertaining to that
state, respectively. Without loss of generality, we consider, for each
predicate $q \in Q$ and each input event $a \in \Sigma$, at most one
such rule (two or more rules can be joined using disjunction). The
\emph{size} of $\A$ is defined as $\len{\A} = \len{\iota} +
\sum_{q(\vec{y}) \arrow{a(X)}{} \psi \in \Delta} \len{\psi}$.

Given a predicate $q \in Q$ and a tuple of data values
$d_1,\ldots,d_{\#(q)}$, the tuple $q(d_1,\ldots,d_{\#(q)})$ is called
a \emph{configuration}\footnote{Note that a configuration is not a
  logical term since data values cannot be written in logic.}.
Because we consider an alternating model of computation, an automaton
can find itself, at the same time, in more than one
configuration. Typically, in the classical literature on alternating
machines, this set is finite. In our case, due to the presence of
first-order quantifiers ranging over an infinite data domain, we
consider that an automaton can be also in an infinite set of
configurations, all at once.

To simplify the presentation, at this point, we shall give the
execution semantics of automata in terms of symbolic rewriting rules.
The connection between this symbolic semantics and the concrete
semantics, expressed in terms of sets of configurations, will be given
at a later time. Let $\stamp{X}{i} = \set{\stamp{x}{i} \mid x \in X}$
be a set of \emph{time-stamped} variables. For a formula $\psi$ and $i
\in \nat$, we define $\stamp{\psi}{i} = \psi[X/\stamp{X}{i}]$,
i.e.\ the formula in which each variable $x \in X$, denoting an input
data element, is replaced by $\stamp{x}{i}$. Further, given a formula
$\phi$, let $\Accept{F}{\phi}$ be the formula obtained from $\phi$ by
replacing each predicate atom $q(z_1,\ldots,z_{\#(q)})$ by $\top$ if
$q \in F$, and by $\bot$, otherwise.

For an input word $(a_1,\nu_1) \ldots (a_n,\nu_n) \in \Sigma[X]^*$,
we define the sequence of formulae \(\phi_0 \Rightarrow \phi_1
\Rightarrow \ldots \Rightarrow \phi_n\), where $\phi_0 = \iota$ and
$\phi_{i+1}$ is obtained from $\phi_i$ by replacing each predicate
atom $q(z_1,\ldots,z_{\#(q)})$ from $\phi_i$ by the formula
$\stamp{\psi}{i+1}[z_1, \ldots, z_{\#(q)}/y_1,\ldots,y_{\#(q)}]$,
where $q(y_1,\ldots,y_{\#(q)}) \arrow{a_i(X)}{} \psi \in \Delta$ is
the only transition rule that applies, or by $\bot$, if no transition
rule applies. Observe that $\phi_n$ is uniquely defined by the event
sequence $a_1 \ldots a_n \in \Sigma^*$. The word $(a_1,\nu_1) \ldots
(a_n,\nu_n)$ is \emph{accepted} by $\A$ if and only if $\I,\nu \models
\Accept{F}{\phi_n}$, where the valuation $\nu : \bigcup_{i=1}^n
\stamp{X}{i} \rightarrow \Data^\I$ is defined as $\nu(\stamp{x}{i}) =
\nu_i(x)$, for each $x \in X$ and $i \in [n]$.

As usual, the \emph{language} of $\A$, denoted $\lang{\A}$, is the set
of words accepted by $\A$. In this paper, we ask the following
questions: \begin{compactenum}
\item \emph{closure}: given automata $\A_i =
  \tuple{\Sigma,X,Q_i,\iota_i,F_i,\Delta_i}$, for $i=1,2$, do there
  exist automata $\A_\cap$, $\A_\cup$ and $\overline{\A}_1$ such that
  $L(\A_\cap) = L(\A_1) \cap L(\A_2)$, $L(\A_\cup) = L(\A_1) \cup
  L(\A_2)$ and $L(\overline{\A}_1) = \Sigma[X]^* \setminus L(\A_1)$ ?
%
\item \emph{emptiness}: given an automaton $\A$, is $L(\A) =
  \emptyset$?
\end{compactenum}

\subsection{Closure Properties}

Given a positive formula $\phi$, we define the \emph{dual} formula
$\dual{\phi}$ recursively on the structure of $\phi$ as follows: 
\[\begin{array}{rclcrclcrcl}
\dual{(\phi_1 \vee \phi_2)} & = & \dual{\phi_1} \wedge \dual{\phi_2} && 
\dual{(\phi_1 \wedge \phi_2)} & = & \dual{\phi_1} \wedge \dual{\phi_2} &&
\dual{(t \teq s)} & = & \neg(t \teq s) \\
\dual{(\exists x ~.~ \phi_1)} & = & \forall x ~.~ \dual{\phi_1} && 
\dual{(\forall x ~.~ \phi_1)} & = & \exists x ~.~ \dual{\phi_1} && 
\dual{(\neg(t \teq s))} & = & t \teq s \\
\dual{(q(x_1,\ldots,x_{\#(q)}))} & = & q(x_1,\ldots,x_{\#(q)})
\end{array}\]
Observe that, because predicate atoms do not occur negated in $\phi$,
there is no need to define dualization for formulae of the form $\neg
q(x_1,\ldots,x_{\#(q)})$. The dualization operation has the following
property:
\begin{lemma}\label{lemma:dual}
  Given a formula $\phi$ and an automaton
  $\A=\tuple{\Sigma,X,Q,\iota,F,\Delta}$, we have the equivalence
  $\Accept{F}{\phi} \equiv \neg(\dual{\Accept{Q\setminus F}{\phi}})$. 
\end{lemma}
\proof{ By straightforward induction on the structure of $\phi$. \qed}

The following theorem shows that first-order alternating data automata
are closed under all boolean operations: 

\begin{theorem}\label{thm:closure}
  Given automata $\A_i = \tuple{\Sigma,X,Q_i,\iota_i,F_i,\Delta_i}$,
  for $i=1,2$, such that $Q_1 \cap Q_2 = \emptyset$, the following hold: 
  \begin{compactitem}
    \item\label{it1:closure} $\lang{\A_\cap} = \lang{\A_1} \cap \lang{\A_2}$, where
      $\A_\cap = \tuple{\Sigma,X,Q_1 \cup Q_2, \iota_1 \wedge \iota_2,
      F_1 \cup F_2, \Delta_1 \cup \Delta_2}$, 
      %
    \item\label{it2:closure} $\lang{\overline{\A_i}} = \Sigma[X]^* \setminus
      \lang{\A_i}$, where $\overline{\A_i} =
      \tuple{\Sigma,X,Q_i,\dual{\iota},Q_i\setminus
        F_i,\overline{\Delta_i}}$ and, for all
      $i=1,2$: \[q(x_1,\ldots,x_{\#(q)}) \arrow{a(X)}{} \phi \in
      \Delta_i \iff q(x_1,\ldots,x_{\#(q)}) \arrow{a(X)}{} \dual{\phi}
      \in \overline{\Delta_i} \enspace.\]
  \end{compactitem}
  Moreover, $\len{\A_\cap} = \bigO{\len{\A_1}+\len{\A_2}}$ and
  $\len{\overline{\A_i}} = \bigO{\len{\A_i}}$, for all $i=1,2$.
\end{theorem}
\proof{\qed}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{abbrv} \bibliography{refs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
