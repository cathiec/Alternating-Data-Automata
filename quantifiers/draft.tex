\documentclass{llncs}
% \documentclass[10pt,conference,letterpaper,twocolumn]{IEEEtran}

\usepackage[usenames,dvipsnames]{color}

\usepackage{latexsym}
\usepackage{amsxtra} 
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{pslatex}
\usepackage{epsfig}
\usepackage{wrapfig}
\usepackage{paralist}
% \usepackage{stmaryrd}
\usepackage{txfonts}
\usepackage{framed}
\usepackage{makecell}
\usepackage{url}
\usepackage{tikz}
\usetikzlibrary{automata,positioning, calc}
\usepackage[inline,shortlabels]{enumitem}

\usepackage{proof}

\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}

\usepackage[draft]{commenting}

\pagestyle{plain}

\include{commands-lncs}

\declareauthor{ri}{Radu}{blue}
\declareauthor{xx}{Xiao}{red}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{First Order Alternation}

\author{Radu Iosif and Xiao Xu}
\institute{
  CNRS, Verimag, Universit\'e de Grenoble Alpes \\
  Email: \{Radu.Iosif,Xiao.Xu\}@univ-grenoble-alpes.fr
}

\maketitle

\begin{abstract}
\end{abstract}

\section{Preliminaries}

For two integers $0 \leq i \leq j$, we denote by $[i,j]$ the set
$\set{i,i+1,\ldots,j}$ and by $[i]$ the set $[0,i]$. To simplify the
presentation, we consider two sorts $\Data$ and $\Bool$, where $\Data$
is an infinite domain and $\Bool$ is the set of truth values $\top$
(true) and $\bot$ (false). The $\Data$ sort is equipped with finitely
many function symbols $f : \Data^{\#(f)} \rightarrow \Data$, where
$\#(f)\geq0$ denotes the number of arguments (arity) of $f$. When
$\#(f)=0$, we say that $f$ is a constant. A \emph{predicate} is a
function symbol $p : \Data^{\#(p)} \rightarrow \Bool$, denoting a
relation of arity $\#(p)$ and we write $\preds$ for the set of
predicates. In the following, we shall consider that the
interpretation of all function symbols $f : \Data^{\#(f)} \rightarrow
\Data$ that are not predicates is fixed and relative to the
interpretation of the $\Data$ sort. For simplicity, we further blur
the notational distinction between function symbols and their
interpretations.

Let $\vars = \set{x,y,z,\ldots}$ be an infinite countable set of
variables, ranging over the interpretation of the $\Data$ sort. Terms
are either constants of sort $\Data$, variables or function
applications. The set of first-order formulae is defined by the syntax
below:
\[\phi := t \teq s \mid p(t_1,\ldots,t_{\#(p)}) 
\mid \neg \phi_1 \mid \phi_1 \wedge \phi_2 \mid \exists x ~.~
\phi_1 \] where $t,s,t_1,\ldots,t_{\#(p)}$ denote terms. We write
$\phi_1 \vee \phi_2$, $\phi_1 \Rightarrow \phi_2$ and $\forall x ~.~
\phi_1$ for $\neg(\neg\phi_1 \wedge \neg\phi_2)$, $\neg\phi_1 \vee
\phi_2$ and $\neg\exists x ~.~ \neg\phi_1$, respectively. We denote by
$\fv{}{\phi}$ the set of free variables in $\phi$. A \emph{sentence}
is a formula $\phi$ in which each variable occurs under the scope of a
quantifier, i.e. $\fv{}{\phi} = \emptyset$. A formula is
\emph{positive} if each predicate symbol occurs under an even number
of negations. The size $\len{\phi}$ of a formula $\phi$ is the number
of symbols needed to write it down.

%% For a variable $x \in \fv{}{\phi}$ and a term $t$, let $\phi[t/x]$ be
%% the result of replacing each occurrence of $x$ by $t$. For indexed
%% sets of terms $T=\set{t_1,\ldots,t_n}$ and variables
%% $X=\set{x_1,\ldots,x_n}$, we write $\phi[T/X]$ for the formula
%% obtained by simultaneously replacing each occurrence of $x_i$ with
%% $t_i$ in $\phi$, for all $i\in[n]$.

An \emph{interpretation} $\I$ maps each predicate $p$ into a set $p^\I
\subseteq \Data^{\#(p)}$, if $\#(p)>0$, or into an element of $\Data$
if $\#(p)=0$. A \emph{valuation} $\nu$ maps each variable $x$ into an
element of $\Data$. Given a term $t$, we denote by $t^\nu$ the value
obtained by replacing each variable $x$ by the value $\nu(x)$ and
evaluating each function application. For a formula $\phi$, we define
the forcing relation $\I,\nu \models \phi$ recursively on the
structure of $\phi$, as follows:
\[
\begin{array}{rcl}
\I,\nu \models t \teq s & \iff & t^\nu=s^\nu \\
\I,\nu \models p(t_1,\ldots,t_{\#(p)}) & \iff & \tuple{t_1^\nu,\ldots,t_{\#(p)}^\nu} \in p^\I \\
\I,\nu \models \neg\phi_1 & \iff & \I,\nu \not\models \phi_1 \\
\I,\nu \models \phi_1 \wedge \phi_2 & \iff & \I,\nu \models \phi_i \text{, for all } i=1,2 \\ 
\I,\nu \models \exists x ~.~ \phi_1 & \iff & \I,\nu[x\leftarrow d] \models \phi_1 \text{, for some } d \in \Data 
\end{array}
\]
For a formula $\phi$, we define $\sem{\phi}_\nu \isdef \set{\I \mid
  \I,\nu \models \phi}$, where $\nu(x)$ is defined for each $x \in
\fv{}{\phi}$, and drop the subscript for sentences. A sentence $\phi$
is \emph{satisfiable} if $\sem{\phi}\neq\emptyset$, an element of
$\sem{\phi}$ being called a \emph{model} of $\phi$.

Interpretations are partially ordered by the pointwise subset order,
defined as $\I_1 \subseteq \I_2$ if and only if $p^{\I_1} \subseteq
p^{\I_2}$ for each predicate $p \in \preds$. Given a set $\mathcal{S}$
of interpretations, a minimal element $\I \in \mathcal{S}$ is an
interpretation such that for no other interpretation $\I' \in
\mathcal{S} \setminus \set{\I}$ do we have $\I' \subseteq \I$. For a
formula $\phi$ and a valuation $\nu$, we denote by $\minsem{\phi}_\nu$
and $\minsem{\phi}$ the set of minimal interpretations from
$\sem{\phi}_\nu$ and $\sem{\phi}$, respectively.

\section{First Order Alternating Automata}

Let $\Sigma$ be a finite alphabet $\Sigma$ of \emph{input
  events}. Given a finite set of variables $X$, we denote by $X
\mapsto \Data$ the set of valuations of the variables $X$ and
$\Sigma[X] = \Sigma \times (X \mapsto \Data)$ be the possibly infinite
set of \emph{data symbols} $(a,\nu)$, where $a$ is an input symbol and
$\nu$ is a valuation. A \emph{data word} (simply called word in the
following) is a finite sequence $w=(a_1,\nu_1)(a_2,\nu_2) \ldots
(a_n,\nu_n)$ of data symbols. Given a word $w$, we denote by
$\event{w} \isdef a_1\ldots a_n$ its sequence of input events and by
$\data{w}$ the valuation associating each time-stamped variable
$\stamp{x}{i}$ the value $\nu_i(x)$, for all $x \in \vars$ and
$i\in[1,n]$. We denote by $\varepsilon$ the empty sequence, by
$\Sigma^*$ the set of finite sequences of input events and by
$\Sigma[X]^*$ the set of data words over the variables $X$.

A \emph{first-order alternating automaton} (simply called automaton in
the following) is a tuple $\A = \tuple{\Sigma,X,Q,\iota,F,\Delta}$,
where $\Sigma$ is the finite event alphabet, $X$ is a finite set of
variables, $Q$ is a finite set of predicates, $\iota$ is a satisfiable
sentence, $F \subseteq Q$ is the set of \emph{final} predicates and
$\Delta$ is a set of \emph{transition rules} of the form
\(q(y_1,\ldots,y_{\#(q)}) \arrow{a(X)}{} \psi\), where $q \in Q$ is a
predicate, $a \in \Sigma$ is an input event, $X \cap
\set{y_1,\ldots,y_{\#(q)}} = \emptyset$, $\psi$ is a positive formula
such that $\fv{}{\phi} \subseteq X \cup \set{y_1,\ldots,y_{\#(q)}}$
and each predicate that occurs in $\psi$ belongs also to $Q$. The
\emph{size} of $\A$ is defined as $\len{\A} = \len{\iota} +
\sum_{\scriptscriptstyle{q(\vec{y}) \arrow{a(X)}{} \psi \in \Delta}}
\len{\psi}$.

The intuition of a transition rule \(q(y_1,\ldots,y_{\#(q)})
\arrow{a(X)}{} \psi\) is the following: $a$ is the input event and $X$
are the input data values that trigger the transition, whereas $q$ and
$y_1,\ldots,y_{\#(q)}$ are the current control state and data values
in that state, respectively. Without loss of generality, we consider,
for each predicate $q \in Q$ and each input event $a \in \Sigma$, at
most one such rule --- two or more rules can be joined using
disjunction.

The execution semantics of automata is given in close analogy with the
case of boolean alternating automata, with transition rules of the
form $q \arrow{a}{} \phi$, where $q$ is a boolean constant and $\phi$
a positive boolean combination of such constants. For instance, $q_0
\arrow{a}{} q_1 \wedge q_2 \vee q_3$ means that the automaton can
choose to transition in either both $q_1$ and $q_2$ or in $q_3$
alone. This intuition leads to saying that the steps of the automaton
are defined by the minimal boolean models of the transition
formulae. In this case, both $\set{q_1 \leftarrow \top, q_2 \leftarrow
  \top, q_3 \leftarrow \bot}$ and $\set{q_1 \leftarrow \bot, q_2
  \leftarrow \bot, q_3 \leftarrow \top}$ are minimal models, however
$\set{q_1 \leftarrow \top, q_2 \leftarrow \top, q_3 \leftarrow \top}$,
is a model but is not minimal\footnote{To avoid the confusion of
  considering potentially non-minimal models, the original definition
  of alternating finite-state automata \cite{ChandraKozenStockmeyer81}
  uses boolean valuations instead of formulae.}.

Given a predicate $q \in Q$ and a tuple of data values
$d_1,\ldots,d_{\#(q)}$, the tuple $q(d_1,\ldots,d_{\#(q)})$ is called
a \emph{configuration}\footnote{Note that a configuration is not a
  logical term since data values cannot be written in logic.}. To
formalize the execution semantics of automata, we relate sets of
configurations to models of first-order sentences, as follows. Given a
formula $\phi$ and a valuation of its free variables $\nu$, each
interpretation $\I \in \sem{\phi}_\nu$ corresponds to a set of
configurations $\cube{\I} \isdef \set{q(d_1,\ldots,d_{\#(q)}) \mid
  \tuple{d_1,\ldots,d_{\#(q)}} \in q^\I, q \in Q}$, called a
\emph{cube}. For a set $\mathcal{S}$ of interpretations, we define
$\cube{\mathcal{S}} \isdef \set{\cube{\I} \mid \I \in
  \mathcal{S}}$. Given a word $w=(a_1,\nu_1) \ldots (a_n,\nu_n) \in
\Sigma[X]^*$, an \emph{execution} of
$\A=\tuple{\Sigma,X,Q,\iota,F,\Delta}$ over $w$ is a (possibly
infinite) forest $\F = \set{T_1,T_2,\ldots}$, where each tree $T_i$ is
such that:
\begin{compactitem}
\item the roots of $T_1, T_2, \ldots$ form a cube from
  $\cube{\minsem{\iota}}$, % --- because $\iota$ is satisfiable, such
                           % a cube always exists,
%
% \item all paths from the root to a leaf of $T_i$ have length $n$, and
%
\item if $q(d_1,\ldots,d_{\#(q)})$ is a node on the level $j \in
  [n-1]$ in $T_i$, then its children form a cube from
  $\cube{\minsem{\psi}_\eta}$, where \(q(y_1,\ldots,y_{\#(q)})
  \arrow{a_{j+1}(X)}{} \psi \in \Delta\) is a transition rule and
  $\eta$ is a valuation that assigns each variable $y_k$ the value
  $d_k$, for $k \in [1,\#(q)]$ and each variable $x \in X$ the value
  $\nu_{j+1}(x)$. % --- because $\fv{}{\psi} \subseteq X \cup
                  % \set{y_1,\ldots,y_{\#(q)}}$, the values assigned
                  % by $\eta$ to variables outside $X \cup
                  % \set{y_1,\ldots,y_{\#(q)}}$ have no impact on
                  % $\cube{\minsem{\psi}_\eta}$.
\end{compactitem}
An execution $\F$ over $w$ is said to be \emph{accepting} if and only
if \begin{inparaenum}[(i)]
\item all paths in $\F$ have the same length $n$, and
\item the frontier of each tree $T \in \F$ is labeled with \emph{final
  configurations} $q(d_1,\ldots,d_{\#(q)})$, where $q \in F$ is a
  final predicate.
\end{inparaenum} In this case, we say that $\A$ accepts $w$ and
denote by $\lang{\A}$ the set of words accepted by $\A$. 

In this paper, we answer the following questions: \begin{compactenum}
\item \emph{closure}: given automata $\A_i =
  \tuple{\Sigma,X,Q_i,\iota_i,F_i,\Delta_i}$, for $i=1,2$, do there
  exist automata $\A_\cap$, $\A_\cup$ and $\overline{\A}_1$ such that
  $L(\A_\cap) = L(\A_1) \cap L(\A_2)$, $L(\A_\cup) = L(\A_1) \cup
  L(\A_2)$ and $L(\overline{\A}_1) = \Sigma[X]^* \setminus L(\A_1)$ ?
%
\item \emph{emptiness}: given an automaton $\A$, is $L(\A) =
  \emptyset$?
\end{compactenum}

\subsection{Symbolic Execution}

In the upcoming developments it is more convenient to work with
logical formulae defining executions. Let $\A =
\tuple{\Sigma,X,Q,\iota,F,\Delta}$ be an automaton for the rest of
this session. For any $i \in \nat$, we denote by $\stamp{Q}{i} =
\set{\stamp{q}{i} \mid q \in Q}$ and $\stamp{X}{i} = \set{\stamp{x}{i}
  \mid x \in X}$ the sets of time-stamped predicates and variables,
respectively. For a formula $\psi$ and $i \in \nat$, we define
$\stamp{\psi}{i} \isdef \psi[\stamp{X}{i}/X,\stamp{Q}{i}/Q]$ the
formula in which all input variables and state predicates (and only
those symbols) are replaced by their time-stamped counterparts. Given
a sequence of input events $\alpha = a_1 \ldots a_n$, the \emph{path
  formula} of $\alpha$ (in $\A$) is defined as follows:
\[\pathform{\alpha} \isdef \stamp{\iota}{0} \wedge 
\bigwedge_{i=1}^n \bigwedge_{q(y_1,\ldots,y_{\#(q)}) \arrow{a_i(X)}{}
  \psi \in \Delta} \forall y_1 \ldots \forall y_{\#(q)} ~.~
\stamp{q}{i-1}(y_1,\ldots,y_{\#(q)}) \Longrightarrow \stamp{\psi}{i}\]
The automaton $\A$, to which $\pathform{\alpha}$ refers, will always
be clear from the context. To formalize the relation between the
low-level configuration-based execution semantics and the symbolic
path formulae, consider a word $w=(a_1,\nu_1) \ldots (a_n,\nu_n)$. Any
execution forest $\F$ of $\A$ over $w$ is associated an interpretation
$\I_{\F}$ of the set of time-stamped predicates $\set{\stamp{q}{i}
  \mid q \in Q, i \in [n]}$, defined as follows:
\[\I_{\F}(\stamp{q}{i}) \isdef \set{\tuple{d_1,\ldots,d_{\#(q)}}
  \mid q(d_1,\ldots,d_{\#(q)}) \text{ occurs on level $i$ in
    $\F$}}\enspace.\]

\begin{lemma}\label{lemma:path-formula}
  Given an automaton $\A = \tuple{\Sigma,X,Q,\iota,F,\Delta}$, for any
  word $w=(a_1,\nu_1) \ldots (a_n,\nu_n)$, we have 
  \(\minsem{\pathform{w_\Sigma}}_{w_\Data} = \set{\I_{\F} \mid \F
    \text{ is an execution of $\A$ over $w$}}\). 
\end{lemma}
\proof{ ``$\subseteq$'' Let $\I$ be a minimal interpretation such that
  $\I,w_\Data \models \pathform{w_\Sigma}$. We show that there exists
  an execution $\F$ of $\A$ over $w$ such that $\I = \I_\F$, by
  induction on $n\geq 0$. For $n=0$, we have $w=\epsilon$ and
  $\pathform{w_\Sigma} = \stamp{\iota}{0}$. Because $\iota$ is a
  sentence, the valuation $w_\Data$ is not important in $\I,w_\Data
  \models \stamp{\iota}{0}$ and, moreover, since $\I$ is minimal, we
  have $\I \in \minsem{\stamp{\iota}{0}}$. We define the
  interpretation $\J(q)=\I(\stamp{q}{0})$, for all $q \in Q$. Then
  $\cube{\J}$ is an execution of $\A$ over $\epsilon$ and $\I =
  \I_{\cube{\J}}$ is immediate. For the inductive case $n>0$, we
  assume that $w=u\cdot(a_n,\nu_n)$ for a word $u$. Let $\J$ be the
  interpretation defined as $\I$ for all $\stamp{q}{i}$, with $q \in
  Q$ and $i \in [n-1]$, and $\emptyset$ everywhere else. Then
  $\J,u_\Data \models \pathform{u_\Sigma}$ and $\J$ is moreover
  minimal. By the induction hypothesis, there exists an execution $\G$
  of $\A$ over $u$, such that $\J = \I_\G$. Consider a leaf of a tree
  $T \in \G$, labeled with a configuration $q(d_1,\ldots,d_{\#(q)})$
  and let $\forall y_1 \ldots \forall y_{\#(q)} ~.~
  \stamp{q}{n-1}(y_1,\ldots,y_{\#(q)}) \Rightarrow \stamp{\psi}{n}$ be
  the subformula of $\pathform{w_\Sigma}$ corresponding to the
  application(s) of the transition rule $q(y_1,\ldots,y_{\#(q)})
  \arrow{a_n}{} \psi$ at the $(n-1)$-th step. Let $\nu$ be the
  valuation that assigns each $y_i$ the value $d_i$, for all $i \in
  [1,\#(q)]$ and behaves like $w_\Data$ outside of
  $\set{y_1,\ldots,y_{\#(d)}}$. Because $\I, w_\Data \models \forall
  y_1 \ldots \forall y_{\#(q)} ~.~
  \stamp{q}{n-1}(y_1,\ldots,y_{\#(q)}) \Rightarrow \stamp{\psi}{n}$,
  we have $\I \in \sem{\stamp{\psi}{n}}_{\nu}$ and let $\K$ be one of
  the minimal interpretations such that $\K \subseteq \I$ and $\K \in
  \sem{\stamp{\psi}{n}}_{\nu}$. It is not hard to see that $\K$ exists
  and is unique, otherwise we could take the pointwise intersection of
  two or more such interpretations. We define the interpretation
  $\overline{\K}(q) = \overline{\K}(\stamp{q}{n})$ for all $q \in
  Q$. We have that $\overline{\K} \in \minsem{\psi}_{\nu}$ --- if
  $\overline{\K}$ was not minimal, $\K$ was not minimal to start with,
  contradiction. Then we extend the execution $\G$ by appending to
  each node labeled with a configuration $q(d_1, \ldots, d_{\#(q)})$
  the cube $\cube{\overline{\K}}$. By repeating this step for all
  leaves of a tree in $\G$, we obtain an execution of $\A$ over $w$.
  
  ``$\supseteq$'' Let $\F$ be an execution of $\A$ over $w$. We show
  that $\I_{\F}$ is a minimal interpretation such that $\I_{\F},
  w_\Data \models \pathform{w_\Sigma}$, by induction on $n \geq
  0$. For $n=0$, $\F$ is a cube from $\cube{\minsem{\iota}}$, by
  definition. Then $\I_{\F} \models \stamp{\iota}{0}$ and moreover, it
  is a minimal such interpretation. For the inductive case $n > 0$,
  let $w=u\cdot(a_n,\nu_n)$ for a word $u$. Let $\G$ be the
  restriction of $\F$ to $u$. Consequently, $\I_\G$ is the restriction
  of $\I_\F$ to $\bigcup_{i=0}^{n-1} \stamp{Q}{i}$. By the inductive
  hypothesis, $\I_{\G}$ is a minimal interpretation such that
  \(\I_{\G}, u_{\Data} \models \pathform{u_\Sigma}\). Since
  $\I_{\F}(\stamp{q}{n}) = \set{\tuple{d_1,\ldots,d_{\#(q)}} \mid
    q(d_1,\ldots,d_{\#(q)}) \text{ occurs on the $n$-th level in
      $\F$}}$, we have $\I_{\F}, w_\Data \models \varphi$, for each
  subformula $\varphi = \forall y_1 \ldots \forall y_{\#(q)} ~.~
  \stamp{q}{n-1}(y_1,\ldots,y_{\#(q)}) \Rightarrow \stamp{\psi}{n}$ of
  $\pathform{w_\Sigma}$, by the execution semantics of $\A$. This is
  the case because the children of each node labeled with
  $q(d_1,\ldots,d_{\#(q)})$ on the $(n-1)$-th level of $\F$ form a
  cube from $\cube{\minsem{\psi}_\nu}$, where $\nu$ is a valuation
  that assigns each $y_i$ the value $d_i$ and behaves like $w_\Data$,
  otherwise. Now supppose, for a contradiction, that $\I_{\F}$ is not
  minimal and let $\J \subsetneq \I_{\F}$ be an interpretation such
  that $\J,w_\Data \models \pathform{w_\Sigma}$. First, we show that
  the restriction $\J'$ of $\J$ to $\bigcup_{i=0}^{n-1} \stamp{Q}{i}$
  must coincide with $\I_{\G}$. Assuming this is not the case,
  i.e.\ $\J' \subsetneq \I_{\G}$, contradicts the minimality of
  $\I_{\G}$. Then the only possibility is that $\J(\stamp{q}{n})
  \subsetneq \I_{\F}(\stamp{q}{n})$, for some $q \in Q$. Let
  $p_1(y_1,\ldots,y_{\#(p_1)}) \arrow{a_n}{} \psi_1, \ldots,
  p_k(y_1,\ldots,y_{\#(p_k)}) \arrow{a_n}{} \psi_k$ be the set of
  transition rules in which the predicate symbol $q$ occurs. Then it
  must be the case that, for some node $p_i(d_1,\ldots,d_{\#(p_i)})$
  on the $(n-1)$-th level of $\G$, the set of children does not form a
  minimal cube from $\cube{\minsem{\stamp{\psi_i}{n}}}$, which
  contradicts the execution semantics of $\A$. \qed}

Next, we give a logical characterization of acceptance, relative to a
given sequence of input events. 

\begin{lemma}\label{lemma:acceptance}
  Given an automaton $\A = \tuple{\Sigma,X,Q,\iota,F,\Delta}$ and a
  sequence of input events $\alpha = a_1 \ldots a_n \in \Sigma^*$, the
  formula $\accform{\alpha} = \pathform{\alpha} \wedge \bigwedge_{q
    \in Q \setminus F} \forall y_1 \ldots \forall y_{\#(q)} ~.~
  \stamp{q}{n}(y_1,\ldots,y_{\#(q)}) \Rightarrow \bot$ is satisfiable
  if and only if $\A$ accepts a word $w$ such that $w_\Sigma =
  \alpha$.
\end{lemma}
\proof{ ``$\Rightarrow$'' Let $\I$ be an interpretation and $\nu$ be a
  valuation such that $\I,\nu \models \accform{\alpha}$. W.l.o.g. we
  consider $\I$ to be a minimal interpretation with this property. Let
  $w$ be the unique word such that $w_\Sigma = \alpha$ and $w_\Data =
  \nu$. By Lemma \ref{lemma:path-formula}, $\A$ has an execution $\F$
  over $w$ such that $\I = \I_{\F}$. To prove that $\F$ is accepting,
  we show that \begin{inparaenum}[(i)]
    \item\label{it1:acceptance} all paths in $\F$ have length $n$ and
      that
    \item\label{it2:acceptance} the frontier of $\F$ is labeled with
      final configurations only. \end{inparaenum} First, assume that
  (\ref{it1:acceptance}) there exists a path in $\F$ of length $0 \leq
  m < n$. Then there exists a node on the $m$-th level, labeled with
  some configuration $q(d_1,\ldots,q_{\#(q)})$, that has no
  children. By the definition of the execution semantics of $\A$, we
  have $\cube{\minsem{\psi}_{\eta}} = \emptyset$, where
  $q(y_1,\ldots,y_{\#(q)}) \arrow{a_{m+1}(X)}{} \psi$ is the transition
  rule of $\A$ that applies for $q$ and $a_{m+1}$ and $\eta$ stands
  for $\nu[y_1 \leftarrow d_1,\ldots,y_{\#(q)} \leftarrow
    d_{\#(q)}]$. Hence $\sem{\psi}_{\eta} = \emptyset$, and because
  $\I,\nu \models \accform{\alpha}$, we obtain that $\I,\eta \models
  q(y_1,\ldots,y_{\#(q)}) \Rightarrow \stamp{\psi}{m+1}$, thus
  $\tuple{d_1,\ldots,d_{\#(q)}} \not\in \I(q)$. However, this
  contradicts the fact that $\I=\I_{\F}$ and that
  $q(d_1,\ldots,d_{\#(q)})$ labels a node of $\F$. Second, assume that
  (\ref{it2:acceptance}), there exists a frontier node of $\F$ labeled
  with a configuration $q(d_1,\ldots,d_{\#(q)})$ such that $q \in Q
  \setminus F$. Since $\I,\nu \models \forall y_1 \ldots \forall
  y_{\#(q)} ~.~ q(y_1,\ldots,y_{\#(q)}) \Rightarrow \bot$, by a
  similar reasoning as in the above case, we obtain that
  $\tuple{d_1,\ldots,d_{\#(q)}} \not\in \I(q)$, contradiction.  

  ``$\Leftarrow$'' Let $\F$ be an accepting execution of $\A$ over
  $w$, where $w_\Sigma = \alpha$. We prove that $\I_\F,w_\Data \models
  \accform{\alpha}$. By Lemma \ref{lemma:path-formula}, we obtain
  $\I_\F,w_\Data \models \pathform{\alpha}$. Since every path in $\F$
  is of length $n$ and all nodes on the $n$-th level of $\F$ are
  labeled by final configurations, we obtain that $\I_F,w_\Data
  \models \bigwedge_{q \in Q \setminus F} \forall y_1 \ldots \forall
  y_{\#(q)} ~.~ \stamp{q}{n}(y_1,\ldots,y_{\#(q)}) \Rightarrow \bot$,
  trivially.  \qed}

\subsection{Closure Properties}

Given a positive formula $\phi$, we define the \emph{dual} formula
$\dual{\phi}$ recursively as follows:
\[\begin{array}{rclcrclcrcl}
\dual{(\phi_1 \vee \phi_2)} & = & \dual{\phi_1} \wedge \dual{\phi_2} && 
\dual{(\phi_1 \wedge \phi_2)} & = & \dual{\phi_1} \wedge \dual{\phi_2} &&
\dual{(t \teq s)} & = & \neg(t \teq s) \\
\dual{(\exists x ~.~ \phi_1)} & = & \forall x ~.~ \dual{\phi_1} && 
\dual{(\forall x ~.~ \phi_1)} & = & \exists x ~.~ \dual{\phi_1} && 
\dual{(\neg(t \teq s))} & = & t \teq s \\
\dual{(q(x_1,\ldots,x_{\#(q)}))} & = & q(x_1,\ldots,x_{\#(q)})
\end{array}\]
Observe that, because predicate atoms do not occur negated in $\phi$,
there is no need to define dualization for formulae of the form $\neg
q(x_1,\ldots,x_{\#(q)})$. 

%% The dualization operation has the following property:
%% \begin{lemma}\label{lemma:dual}
%%   Given a formula $\phi$ and an automaton
%%   $\A=\tuple{\Sigma,X,Q,\iota,F,\Delta}$, we have the equivalence
%%   $\Accept{F}{\phi} \equiv \neg(\dual{\Accept{Q\setminus F}{\phi}})$. 
%% \end{lemma}
%% \proof{ By straightforward induction on the structure of $\phi$. \qed}

The following theorem shows that first-order alternating data automata
are closed under all boolean operations: 

\begin{theorem}\label{thm:closure}
  Given automata $\A_i = \tuple{\Sigma,X,Q_i,\iota_i,F_i,\Delta_i}$,
  for $i=1,2$, such that $Q_1 \cap Q_2 = \emptyset$, the following hold: 
  \begin{compactitem}
    \item\label{it1:closure} $\lang{\A_\cap} = \lang{\A_1} \cap \lang{\A_2}$, where
      $\A_\cap = \tuple{\Sigma,X,Q_1 \cup Q_2, \iota_1 \wedge \iota_2,
      F_1 \cup F_2, \Delta_1 \cup \Delta_2}$, 
      %
    \item\label{it2:closure} $\lang{\overline{\A_i}} = \Sigma[X]^*
      \setminus \lang{\A_i}$, where $\overline{\A_i} =
      \tuple{\Sigma,X,Q_i,\dual{\iota},Q_i\setminus
        F_i,\dual{\Delta}_i}$ and, for $i=1,2$: \[\dual{\Delta}_i =
      \set{q(y_1,\ldots,y_{\#(q)}) \arrow{a(X)}{} \dual{\psi} \mid
        q(y_1,\ldots,y_{\#(q)}) \arrow{a(X)}{} \psi \in
        \Delta_i}\enspace.\]
  \end{compactitem}
  Moreover, $\len{\A_\cap} = \bigO{\len{\A_1}+\len{\A_2}}$ and
  $\len{\overline{\A_i}} = \bigO{\len{\A_i}}$, for all $i=1,2$.
\end{theorem}
\proof{\qed}

\section{The Emptiness Problem}

The problem of checking emptiness of a given automata is undecidable,
for automata using predicates of arity two or more, even if the theory
in which the (right-hand sides of the) transition rules are written
consists of only equalities and disequalities between variables, with
no quantifiers \cite{FarzanKincaidPodelski15}. Thus, we resort to an
abstraction-refinement loop that looks for an accepted word, by firing
longer and longer sequences of input events.

Since, for a countable data domain $\Data$, the set of finite words
$\Sigma[X]^*$ over a finite set of variables $X$ is countable, the
emptiness problem is recursively enumerable in this case. As a
consequence of Lemma \ref{lemma:acceptance}, if the given automaton is
not empty, a semi-algorithm based on a systematic exploration of the
sequences of input events will eventually discover an accepted word,
provided that the first-order data theory is decidable. 

However, if the automaton is empty, the enumeration of input event
sequences will fail to terminate, in general. The classical way to
fight this divergence problem is to consider a \emph{coverage} partial
order, which is a subset of the following relation: 

\begin{definition}\label{def:coverage}
  Given an automaton $\A = \tuple{\Sigma,X,Q,\iota,F,\Delta}$ and
  $S_1, S_2 \subseteq \bigcup_{q \in Q} \set{q(d_1,\ldots,d_{\#(q)})
    \mid d_1,\ldots,d_{\#(q)} \in \Data}$, we have $S_1 \sqsubseteq
  S_2$ if and only if 
  \begin{equation}\label{eq:po}
    \text{
      \begin{minipage}{0.7\textwidth}
        $\A$ accepts a word $w$ when started in a set of cubes $C_1
        \in S_1$ only if $\A$ accepts $w$ when started in a set of
        cubes $C_2 \in S_2$.
    \end{minipage}} 
  \end{equation}
\end{definition}
Since, in general the $\sqsubseteq$ relation is not definable using
available decidable (SMT) theories, we consider the following stronger
relation: $S_1 \supsetforex S_2$ if and only if, for each set of cubes
$C_1 \in S_1$, there exists a set of cubes $C_2 \in S_2$ such that
$C_1 \supseteq C_2$.

\begin{lemma}\label{lemma:coverage}
  Given an automaton $\A = \tuple{\Sigma,X,Q,\iota,F,\Delta}$, for any
  sets of cubes $S_1, S_2 \subseteq \bigcup_{q \in Q}
  \set{q(d_1,\ldots,d_{\#(q)}) \mid d_1,\ldots,d_{\#(q)} \in \Data}$
  such that $S_1 \supsetforex S_2$, we have $S_1 \sqsubseteq S_2$.
\end{lemma}
\proof{  
\qed}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{abbrv} \bibliography{refs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
