We first wish to thank all reviewers for their time and great
work. Below we answer the concerns raised by Reviewers 1 and 4. 

Review 1: 

 1.1 Relation of FOAA with s-AFA. Symbolic (alternating) automata are
 an important extension of finite-state automata to infinite alphabets
 and lacking those references in our paper is a minus that can be
 corrected. One explanation is that we focused on infinite alphabet
 extensions that follow an idea of the seminal works on timed (TA) and
 finite-memory (register) automata (RA). Indeed, both TA and RA relate
 values occurring at different positions in the input, either by using
 clocks (with reset and difference guards) or registers (with
 rewriting and equality guards). This expressivity is paid for in that
 inclusion becomes undecidable (unless severe restrictions on the
 number of clocks/registers apply).

 Our original motivation here was not as much finding decidable
 infinite alphabet alternating automata but rather having a very
 general model, (unsurprisingly) closed under complement and
 intersection, in which all undecidable inclusion problems can be
 encoded, then devise a practical semi-algorithm for it (that works on
 reasonably complex examples). Since, to the best of our knowledge,
 there are no published semi-algorithms for TA or RA inclusion, our
 method could contribute to the state-of-the-art in these areas, as
 well as in program verification (we have considered several programs
 handling integer arrays in our examples).

 1.2 Restrictions of FOAA with decidable emptiness. As proved in [5],
 emptiness of predicate automata is undecidable even for
 quantifier-free rules with equalities and disequalities, not using
 the input variables, when predicates have arities two or more
 (equalities and monadic predicates is decidable though). In the light
 of this result (pg. 9, last paragraph), any reasonably interesting
 extension of monadic predicate automata seems to be undecidable for
 emptiness.

 We also compare with an alternating automaton model [11], in which
 states are propositional variables and comparisons are possible only
 between adjacent input values, without hidden variables. This model
 is intermediate between s-AFA and FOAA, nevertheless emptiness
 remains undecidable (reduction from 2-counter machine reachability).

Review 4:

4.1 Relation with Constrained Horn Clauses (CHC). The main difference
between the unfoldings of CHC and those of FOAA is that, in CHC, the
different branches of the unfolding tree are essentially unrelated,
whereas in FOAA, all branches of the computation tree must synchronize
on the same input word. To account for this synchronization, a CHC
encoding of FOADA must use recursive algebraic data types (lists) to
ensure that, at each step, all incoming branches consider exactly the
same list, encoding the continuation of the input from that point on
(CHC traverse the input from the end to the beginning). The encoding
of FOAA in CHC would benefit from the advantage of using off-the-shelf
CHC solvers, but, in our opinion, faces several practical problems:

I. Checking that, in each clause, all incoming branches have the same
input can be done using equalities between list arguments of the
subgoals. However, the body (left-hand side) of the clause must be
given either as a conjunction or, if quantifiers are considered, as
prenex DNF. In principle, this can be done, but the reduction is a bit
more complex than suggested and, moreover, writing each rule in DNF
can be costly.

II. Introducing a list ADT in the encoding means that the emptiness
checking semi-algorithm relies on an interpolation procedure for
ADTs. Although satisfiability checking for quantifier-free ADTs has
reached maturity and integration with many SMT solvers, interpolation
of ADT theories is at its beginnings. In fact, the 2018 technical
report [*] claims to introduce the first interpolation procedure for
ADTs:

* Hossein Hojjat, Philipp Ruemmer. Deciding and Interpolating
Algebraic Data Types by Reduction. ArXiv:1801.02367. Previous version
appeared in SYNASC'17.

Moreover, the availability of such procedures in off-the-shelf CHC
solvers is still an issue --- the integration of the above procedure
in ELDARICA is underway, according to [*]. However, when such
technical problems are solved, it would definitely be interesting to
have an experimental comparison between, e.g. FOAA and ELDARICA.

III. Working with quantified rules in FOADA requires a quantifier
elimination procedure that produces witness terms. According to [15],
witness-producing quantifier elimination is available for first-order
theories and BAPA. However, if quantified variables occur in the ADT
constructors, the theory is most likely undecidable, thus may not have
quantifier elimination, by an argument similar to the one of [8].

Essentially, for the above reasons, we have chosen to design our
emptiness checking semi-algorithm from scratch, trying to put as few
assumptions as possible on the underlying first-order data theory,
namely (a) Lyndon interpolation for the quantifier-free fragment and
(b) witness term generation for quantifier elimination.
